<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.0">
    <TriggerPackage>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Start up</name>
            <script>quit = 0
send(&quot;outr kola;;eat kola&quot;)
send(&quot;thirdeye&quot;)
send(&quot;hypersight on&quot;)
send(&quot;vigilance on&quot;)
send(&quot;touch mindseye&quot;)
send(&quot;selfishness&quot;)
send(&quot;slipperiness&quot;)
send(&quot;hover up&quot;)
startGame()</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Password correct. Welcome to Achaea.</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>3</integer>
            </regexCodePropertyList>
        </Trigger>
        <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="no">
            <name>Consoles</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#00ff00</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList/>
            <regexCodePropertyList/>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="yes">
                <name>channelCatch</name>
                <script>local chan = gmcp.Comm.Channel.Text.channel
if  string.find(chan, &quot;clt&quot;) or string.find(chan, &quot;hnt&quot;) or chan == &quot;ht&quot; or string.find(chan, &quot;hnt&quot;)
or string.find(chan, &quot;hts&quot;) or string.find(chan, &quot;ct&quot;) or string.find(chan, &quot;tell&quot;) or string.find(chan, &quot;party&quot;) then

deleteLine()
tempLineTrigger(1,1, [[deleteLine()]])
end</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#800000</colorTriggerFgColor>
                <colorTriggerBgColor>#008080</colorTriggerBgColor>
                <regexCodeList>
                    <string>(</string>
                    <string>^(.+)? tell</string>
                    <string>&lt;&lt;</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>2</integer>
                    <integer>1</integer>
                    <integer>2</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Prompt</name>
                <script>local maxhp = tonumber(gmcp.Char.Vitals.maxhp)
local hp = tonumber(gmcp.Char.Vitals.hp)
hpp = math.floor(hp/maxhp * 100)

local maxmp = tonumber(gmcp.Char.Vitals.maxmp)
local mp = tonumber(gmcp.Char.Vitals.mp)
mpp = math.floor(mp/maxmp * 100)

nl = tonumber(gmcp.Char.Vitals.nl)

rg = tonumber(string.match(gmcp.Char.Vitals.charstats[2], &quot;%d+&quot;))

if hpp &gt; 70 then cecho(&quot;&lt;green&gt;[&quot; .. hpp .. &quot;%HP]&quot;)
elseif hpp &gt; 30 then cecho(&quot;&lt;yellow&gt;[&quot; .. hpp .. &quot;%HP]&quot;)
elseif hpp &gt;= 10 then cecho(&quot;&lt;red&gt;[&quot; .. hpp .. &quot;%HP]&quot;)
else cecho(&quot;&lt;red&gt;[0&quot; .. hpp .. &quot;%HP]&quot;)
end

if mpp &gt; 70 then cecho(&quot;&lt;green&gt;[&quot; .. mpp .. &quot;%MP]&quot;)
elseif mpp &gt; 30 then cecho(&quot;&lt;yellow&gt;[&quot; .. mpp .. &quot;%MP]&quot;)
elseif mpp &gt;= 10 then cecho(&quot;&lt;red&gt;[&quot; .. mpp .. &quot;%MP]&quot;)
else cecho(&quot;&lt;red&gt;[0&quot; .. mpp .. &quot;%MP]&quot;)
end

if rg &gt;=100 then cecho(&quot;&lt;white&gt;[XXRG]&quot;)
elseif rg &gt;= 10 then cecho(&quot;&lt;white&gt;[&quot; ..rg .. &quot;RG]&quot;)
else cecho(&quot;&lt;white&gt;[0&quot; .. rg .. &quot;RG]&quot;)
end

if nl &gt;= 10 then cecho(&quot;&lt;white&gt;[&quot; .. nl .. &quot;%XP]&quot;)
else cecho(&quot;&lt;white&gt;[0&quot; .. nl .. &quot;%XP]&quot;)
end

echo(&quot; - &quot;)</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>return isPrompt()</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>4</integer>
                </regexCodePropertyList>
            </Trigger>
        </TriggerGroup>
        <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Combat</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList/>
            <regexCodePropertyList/>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Hunting</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Inhibit on</name>
                    <script>send(&quot;pt &quot; .. target .. &quot; INHIBITED&quot;)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You take a pinch of diamond dust and flick it at</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Inhibit off</name>
                        <script>send(&quot;pt &quot; .. target .. &quot; UNINHIBITED&quot;)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>(.+) coughs one last time and expels the last of the diamond dust that was plaguing him.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Stun on</name>
                    <script>send(&quot;pt &quot; .. target .. &quot;STUNNED&quot;)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You whistle innocuously as you saunter by</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Stun off</name>
                        <script>send (&quot;pt &quot; .. target .. &quot; UNSTUNNED&quot;)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>(.+) rouses himself from his stunned stupor.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Party join and quit</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Party Join</name>
                    <script>if not isInParty then
	echo(&quot;Let's the the party started!&quot;)
	isInParty = true
end</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>^You have joined .+ party.$</string>
                        <string>^You have invited .+ to join a party.$</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>1</integer>
                        <integer>1</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Party Quit</name>
                    <script>if isInParty then
	echo(&quot;Party's over!\n&quot;)
	isInParty = false
end</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You have left your party.</string>
                        <string>You are not the member of any party.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>3</integer>
                        <integer>3</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
        </TriggerGroup>
        <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Fishing</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList/>
            <regexCodePropertyList/>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>nibble</name>
                <script>tempTimer(1.9, [[send(&quot;tease line&quot;)]])</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>You feel a fish nibbling on your hook.</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>3</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Small bite</name>
                <script>tempTimer(1.9, [[send(&quot;tease line&quot;)]])</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>You feel a fish make a small strike at your bait.</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>3</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Medium bite</name>
                <script>tempTimer(2.1, [[send(&quot;jerk line&quot;)]])</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>You see the water ripple as a fish makes a medium strike at your bait.</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>3</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Large bite</name>
                <script>tempTimer(2.1, [[send(&quot;jerk line&quot;)]])</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>You stagger as a fish makes a large strike at your bait.</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>3</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Reel line</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand>reel line</mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>Relaxing the tension on your line, you are able to reel again.</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>3</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Jerked</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand>reel line</mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>You quickly jerk back your fishing pole and feel the line go taut.</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>2</integer>
                </regexCodePropertyList>
            </Trigger>
        </TriggerGroup>
        <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Skills</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList/>
            <regexCodePropertyList/>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Harvesting</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Retry</name>
                    <script>deleteLine()
tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])
tempLineTrigger(1, 1,[[deleteLine()]])
Harvest(harTable)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You cannot find enough suitable material to harvest.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>3</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Harvested</name>
                    <script>if isHar == 1 then
	if harTable[1] == &quot;moss&quot; then
		send(&quot;inr all irid&quot;)
	else
		send(&quot;inr all &quot;.. harTable[1])
	end
	table.remove(harTable, 1)
	Harvest(harTable)
else
	send(&quot;inr all &quot;.. gatTable[1])
	table.remove(gatTable, 1)
	Gather(gatTable)
end</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You reach out and carefully harvest</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Already Harvested</name>
                    <script>deleteLine()
tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])
table.remove(harTable, 1)
Harvest(harTable)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>That plant has been fully harvested.</string>
                        <string>You have already harvested from this plant recently.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>3</integer>
                        <integer>3</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Gathering</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Gathered</name>
                    <script>if gatTable[1] == &quot;red clay&quot; then
	send(&quot;inr all clay&quot;)
else
	send(&quot;inr all &quot;.. gatTable[1])
end
table.remove(gatTable, 1)
Gather(gatTable)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You reach out and carefully gather</string>
                        <string>Carefully scouring the nooks and crannies of the surrounding rock, you gather </string>
                        <string>Sifting through the soft riverbed with your fingers, </string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                        <integer>2</integer>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Retry Gather</name>
                    <script>deleteLine()
tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])
Gather(gatTable)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You cannot find enough suitable material to gather.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>3</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Already Gathered</name>
                    <script>deleteLine()
tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])
table.remove(gatTable, 1)
Gather(gatTable)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You have already gathered </string>
                        <string>You carefully search the cracks and crevices of the surrounding rock, but find nothing.</string>
                        <string>You carefully dig through the soft soil of the riverbed but are unable</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                        <integer>3</integer>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Seeds</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand>inr all seed</mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>With your keen eyes, you spot some additional edibles and you gather \d+ handfuls of seeds to supplement your collection.</string>
                        <string>With your keen eyes, you spot some additional edibles and you gather a handful of seeds to supplement your collection.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>1</integer>
                        <integer>3</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Refining</name>
                    <script>refineAmt = refineAmt - 1
refineIngredient()</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You take a handful of grain and coarsely grind it into a small pile of flour.</string>
                        <string>You use a jewel-encrusted silver tinderbox to refine the chocolate.</string>
                        <string>You use a jewel-encrusted silver tinderbox to refine the sugar.</string>
                        <string>You use a jewel-encrusted silver tinderbox to refine the salt.</string>
                        <string>Crushing a cluster of olives in your fist and grinding it into a thick paste, you rub your palms briskly together, extracting the oil and allowing it to drip into</string>
                        <string>Separating the most promising seeds from the rest, </string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>3</integer>
                        <integer>3</integer>
                        <integer>3</integer>
                        <integer>3</integer>
                        <integer>2</integer>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>flakes</name>
                    <script>send(&quot;inr all reagent&quot;)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>As you cleanse the clay in the riverwater, you discover </string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Jester Stuff</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>bombs</name>
                    <script>if bombAmnt &gt; 0 then
	bombAmnt = bombAmnt - 1
	makeBomb()
else
	send(&quot;combine &quot; .. bombType)
	echo(&quot;\n--CONSTRUCTION COMPLETE!--\n&quot;)
end</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>With agile fingers, you quickly construct</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Tarot gags</name>
                    <script>deleteLine()
tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You shuffle a tarot card inscribed with</string>
                        <string>Wisely preparing yourself beforehand,</string>
                        <string>Focusing your mind on the task ahead, you block out all extraneous thoughts.</string>
                        <string>You take up the quill and begin to trace</string>
                        <string>Finishing the outline, you begin to colour</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                        <integer>2</integer>
                        <integer>3</integer>
                        <integer>2</integer>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Conjuration</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Successful finish</name>
                    <script>conjNumCreate = conjNumCreate - 1

if conjNumCreate &gt; 0 then
	conjureItem(conjToCreate)
end</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You take (a|an) .+? from a beguiling ouroboros.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>1</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Bad finish</name>
                    <script>echo(&quot;\nOh no spaghetti o's!\n\n&quot;)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>There is a flash of unpleasant green light</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
        </TriggerGroup>
        <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Other</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList/>
            <regexCodePropertyList/>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Learning</name>
                <script>if lessonsLeft &gt; 20 then
	send(&quot;learn 20 &quot; .. skill .. &quot; from &quot; .. instructor, false)
	lessonsLeft = lessonsLeft - 20
	echo(lessonsLeft .. &quot; remaining!\n&quot;)
elseif lessonsLeft &lt; 20 then
	send(&quot;learn &quot; .. lessonsLeft .. &quot; &quot; .. skill .. &quot; from &quot; .. instructor)
	echo(&quot;Last lessons!\n&quot;)
end</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>^.+ finishes the lesson in \w+.$</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>1</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>logging</name>
                <script>file:write(line..&quot;\n\n&quot;)</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>return not isPrompt()</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>4</integer>
                </regexCodePropertyList>
            </Trigger>
        </TriggerGroup>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>learning</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand>ok</mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>'OK' to commence the lesson.</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>refine trigger</name>
            <script>if refinesleft &gt; 100 then
	refinesleft = refinesleft - 100
	send(&quot;REFINE 100 &quot; .. torefine)
elseif refinesleft &gt; 0 then
	send(&quot;REFINE &quot; .. refinesleft .. &quot; &quot; .. torefine)
	refinesleft = 0
else
	echo(&quot;\nAll refined!\n&quot;)
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>You refine</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>2</integer>
            </regexCodePropertyList>
        </Trigger>
    </TriggerPackage>
    <TimerPackage>
        <TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
            <name>Inkmilling</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <time>00:00:04.000</time>
            <Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
                <name>redink</name>
                <script>inksleft = inksneeded - inksmilled

if inksmilled &lt; inksneeded then
	if inksmilled &gt; 0 then
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
	end
	if inksleft &gt; 5 then
		if isInRift(&quot;red clay&quot;) then
			send(&quot;outr 5 clay&quot;, false)
		elseif isInRift(&quot;red chitin&quot;) then
			send(&quot;outr 5 redchitin&quot;, false)
		else
			echo(&quot;OUT OF RED REAGENT\n&quot;)
			disableTimer(&quot;redink&quot;)
		end
		if isInRift(&quot;fish scales&quot;) then
			send(&quot;outr 5 scales&quot;, false)
		else
			echo(&quot;OUT OF COMMON REAGENT\n&quot;)
			disableTimer(&quot;redink&quot;)
		end
		send(&quot;put group clay in mill&quot;, false)
		send(&quot;put group scales in mill&quot;, false)
		send(&quot;mill for 5 red&quot;, false)
		inksmilled = inksmilled + 5
	else
		if isInRift(&quot;red clay&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; clay&quot;, false)
		elseif isInRift(&quot;red chitin&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; redchitin&quot;, false)
		else
			echo(&quot;OUT OF RED REAGENT\n&quot;)
			disableTimer(&quot;redink&quot;)
		end
		if isInRift(&quot;fish scales&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; scales&quot;, false)
		else
			echo(&quot;OUT OF COMMON REAGENT\n&quot;)
			disableTimer(&quot;redink&quot;)
		end
		send(&quot;put group clay in mill&quot;, false)
		send(&quot;put group scales in mill&quot;, false)
		send(&quot;mill for &quot;.. inksleft ..&quot; red&quot;, false)
		inksmilled = inksneeded
	end
else
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
		echo(&quot;FINISHED MILLING\n&quot;)
		disableTimer(&quot;redink&quot;)
end</script>
                <command></command>
                <packageName></packageName>
                <time>00:00:04.000</time>
            </Timer>
            <Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
                <name>blueink</name>
                <script>inksleft = inksneeded - inksmilled

if inksmilled &lt; inksneeded then
	if inksmilled &gt; 0 then
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
	end
	if inksleft &gt; 5 then
		if isInRift(&quot;lumic moss&quot;) then
			send(&quot;outr 5 lumic&quot;, false)
			send(&quot;put group lumic in mill&quot;, false)
		elseif isInRift(&quot;ink bladder&quot;) then
			send(&quot;outr 5 bladder&quot;, false)
			send(&quot;put group bladder in mill&quot;, false)
		else
			echo(&quot;OUT OF BLUE REAGENT\n&quot;)
			disableTimer(&quot;blueink&quot;, false)
		end
		if isInRift(&quot;buffalo horn&quot;) then
			send(&quot;outr 5 horn&quot;, false)
		else
			echo(&quot;OUT OF UNCOMMON REAGENT\n&quot;)
			disableTimer(&quot;blueink&quot;)
		end
		send(&quot;put group horn in mill&quot;, false)
		send(&quot;mill for 5 blue&quot;, false)
		inksmilled = inksmilled + 5
	else
		if isInRift(&quot;lumic moss&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; lumic&quot;, false)
			send(&quot;put group lumic in mill&quot;, false)
		elseif isInRift(&quot;ink bladder&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; bladder&quot;, false)
			send(&quot;put group bladder in mill&quot;, false)
		else
			echo(&quot;OUT OF BLUE REAGENT\n&quot;)
			disableTimer(&quot;blueink&quot;)
		end
		if isInRift(&quot;buffalo horn&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; horn&quot;, false)
		else
			echo(&quot;OUT OF UNCOMMON REAGENT\n&quot;)
			disableTimer(&quot;blueink&quot;)
		end
		send(&quot;put group horn in mill&quot;, false)
		send(&quot;mill for &quot;.. inksleft ..&quot; blue&quot;, false)
		inksmilled = inksneeded
	end
else
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
		echo(&quot;FINISHED MILLING\n&quot;)
		disableTimer(&quot;blueink&quot;)
end</script>
                <command></command>
                <packageName></packageName>
                <time>00:00:04.000</time>
            </Timer>
            <Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
                <name>yellowink</name>
                <script>inksleft = inksneeded - inksmilled

if inksmilled &lt; inksneeded then
	if inksmilled &gt; 0 then
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
	end
	if inksleft &gt; 5 then
		if isInRift(&quot;yellow chitin&quot;) then
			send(&quot;outr 5 yellowchitin&quot;, false)
			send(&quot;put group chitin in mill&quot;, false)
		else
			echo(&quot;OUT OF YELLOW REAGENT\n&quot;)
			disableTimer(&quot;yellowink&quot;, false)
		end
		if isInRift(&quot;shark tooth&quot;) then
			send(&quot;outr 5 tooth&quot;, false)
		else
			echo(&quot;OUT OF SCARSE REAGENT\n&quot;)
			disableTimer(&quot;yellowink&quot;)
		end
		send(&quot;put group tooth in mill&quot;, false)
		send(&quot;mill for 5 yellow&quot;, false)
		inksmilled = inksmilled + 5
	else
		if isInRift(&quot;red clay&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; clay&quot;, false)
		elseif isInRift(&quot;red chitin&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; redchitin&quot;, false)
		else
			echo(&quot;OUT OF RED REAGENT\n&quot;)
			disableTimer(&quot;redink&quot;)
		end
		if isInRift(&quot;fish scales&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; scales&quot;, false)
		else
			echo(&quot;OUT OF COMMON REAGENT\n&quot;)
			disableTimer(&quot;redink&quot;)
		end
		send(&quot;put group tooth in mill&quot;, false)
		send(&quot;mill for &quot;.. inksleft ..&quot; yellow&quot;, false)
		inksmilled = inksneeded
	end
else
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
		echo(&quot;FINISHED MILLING\n&quot;)
		disableTimer(&quot;yellowink&quot;)
end</script>
                <command></command>
                <packageName></packageName>
                <time>00:00:04.000</time>
            </Timer>
            <Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
                <name>purpleink</name>
                <script>inksleft = inksneeded - inksmilled

if inksmilled &lt; inksneeded then

	if inksmilled &gt; 0 then
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
	end

	if inksleft &gt; 5 then
		if isInRift(&quot;lumic moss&quot;) then
			send(&quot;outr 10 lumic&quot;, false)
			send(&quot;put group lumic in mill&quot;, false)
		elseif isInRift(&quot;ink bladder&quot;) then
			send(&quot;outr 10 bladder&quot;, false)
			send(&quot;put group bladder in mill&quot;, false)
		else
			echo(&quot;OUT OF BLUE REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end
		if isInRift(&quot;buffalo horn&quot;) then
			send(&quot;outr 10 horn&quot;, false)
		else
			echo(&quot;OUT OF UNCOMMON REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end
		send(&quot;put group horn in mill&quot;)
		if isInRift(&quot;red clay&quot;) then
			send(&quot;outr 10 clay&quot;, false)
			send(&quot;put group clay in mill&quot;)
		elseif isInRift(&quot;red chitin&quot;) then
			send(&quot;outr 10 redchitin&quot;, false)
			send(&quot;put group chitin in mill&quot;)
		else
			echo(&quot;OUT OF RED REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end
		if isInRift(&quot;fish scales&quot;) then
			send(&quot;outr 10 scales&quot;, false)
			send(&quot;put group scales in mill&quot;, false)
		else
			echo(&quot;OUT OF COMMON REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end
		if isInRift(&quot;wyrm tongue&quot;) then
			send(&quot;outr 5 tongue&quot;)
			send(&quot;put group tongue in mill&quot;)
		else
			echo(&quot;OUT OF RARE REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end


		send(&quot;mill for 5 purple&quot;, false)
		inksmilled = inksmilled + 5

	else

		if isInRift(&quot;lumic moss&quot;) then
			send(&quot;outr &quot; .. (inksleft*2) ..&quot; lumic&quot;, false)
			send(&quot;put group lumic in mill&quot;, false)
		elseif isInRift(&quot;ink bladder&quot;) then
			send(&quot;outr &quot; .. (inksleft*2) ..&quot; bladder&quot;, false)
			send(&quot;put group bladder in mill&quot;, false)
		else
			echo(&quot;OUT OF BLUE REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end
		if isInRift(&quot;buffalo horn&quot;) then
			send(&quot;outr &quot; .. (inksleft*2) ..&quot; horn&quot;, false)
		else
			echo(&quot;OUT OF UNCOMMON REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end
		send(&quot;put group horn in mill&quot;)
			if isInRift(&quot;red clay&quot;) then
			send(&quot;outr &quot;.. (inksleft*2) ..&quot; clay&quot;, false)
			send(&quot;put group clay in mill&quot;)
		elseif isInRift(&quot;red chitin&quot;) then
			send(&quot;outr &quot;.. (inksleft*2) ..&quot; redchitin&quot;, false)
			send(&quot;put group chitin in mill&quot;)
		else
			echo(&quot;OUT OF RED REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end
		if isInRift(&quot;fish scales&quot;) then
			send(&quot;outr &quot;.. (inksleft*2) ..&quot; scales&quot;, false)
		else
			echo(&quot;OUT OF COMMON REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end
		send(&quot;put group scales in mill&quot;, false)
		if isInRift(&quot;wyrm tongue&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; tongue&quot;)
			send(&quot;put group tongue in mill&quot;)
		else
			echo(&quot;OUT OF RARE REAGENT\n&quot;)
			disableTimer(&quot;purpleink&quot;)
		end

		send(&quot;mill for &quot;.. (inksleft) ..&quot; purple&quot;, false)
		inksmilled = inksneeded
	end

else
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
		tempTimer(0.1, [[echo(&quot;FINISHED MILLING\n&quot;)]])
		disableTimer(&quot;purpleink&quot;)
end</script>
                <command></command>
                <packageName></packageName>
                <time>00:00:04.000</time>
            </Timer>
            <Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
                <name>greenink</name>
                <script>inksleft = inksneeded - inksmilled

if inksmilled &lt; inksneeded then
	if inksmilled &gt; 0 then
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
	end

	if inksleft &gt; 5 then
		if isInRift(&quot;lumic moss&quot;) then
			send(&quot;outr 10 lumic&quot;, false)
			send(&quot;put group lumic in mill&quot;, false)
		elseif isInRift(&quot;ink bladder&quot;) then
			send(&quot;outr 10 bladder&quot;, false)
			send(&quot;put group bladder in mill&quot;, false)
		else
			echo(&quot;OUT OF BLUE REAGENT\n&quot;)
			disableTimer(&quot;greenink&quot;)
		end

		if isInRift(&quot;buffalo horn&quot;) then
			send(&quot;outr 10 horn&quot;, false)
		else
			echo(&quot;OUT OF UNCOMMON REAGENT\n&quot;)
			disableTimer(&quot;greenink&quot;)
		end
		send(&quot;put group horn in mill&quot;)

		if isInRift(&quot;yellow chitin&quot;) then
			send(&quot;outr 5 yellowchitin&quot;, false)
			send(&quot;put group yellowchitin in mill&quot;, false)
		else
			echo(&quot;OUT OF YELLOW REAGENT\n&quot;)
			disableTimer(&quot;greenink&quot;)
		end

		if isInRift(&quot;shark tooth&quot;) then
			send(&quot;outr 5 tooth&quot;, false)
		else
			echo(&quot;OUT OF SCARSE REAGENT\n&quot;)
			disableTimer(&quot;greenink&quot;)
		end
		send(&quot;put group sharktooth in mill&quot;, false)
		send(&quot;mill for 5 green&quot;, false)
		inksmilled = inksmilled + 5

	else
		if isInRift(&quot;lumic moss&quot;) then
			send(&quot;outr &quot; .. (inksleft*2) ..&quot; lumic&quot;, false)
			send(&quot;put group lumic in mill&quot;, false)
		elseif isInRift(&quot;ink bladder&quot;) then
			send(&quot;outr &quot; .. (inksleft*2) ..&quot; bladder&quot;, false)
			send(&quot;put group bladder in mill&quot;, false)
		else
			echo(&quot;OUT OF BLUE REAGENT\n&quot;)
			disableTimer(&quot;greenink&quot;)
		end

		if isInRift(&quot;buffalo horn&quot;) then
			send(&quot;outr &quot; .. (inksleft*2) ..&quot; horn&quot;, false)
		else
			echo(&quot;OUT OF UNCOMMON REAGENT\n&quot;)
			disableTimer(&quot;greenink&quot;)
		end
		send(&quot;put group horn in mill&quot;)

		if isInRift(&quot;yellow chitin&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; yellowchitin&quot;, false)
			send(&quot;put group yellowchitin in mill&quot;, false)
		else
			echo(&quot;OUT OF YELLOW REAGENT\n&quot;)
			disableTimer(&quot;greenink&quot;)
		end

		if isInRift(&quot;shark tooth&quot;) then
			send(&quot;outr &quot;.. inksleft ..&quot; tooth&quot;, false)
		else
			echo(&quot;OUT OF SPARSE REAGENT\n&quot;)
			disableTimer(&quot;greenink&quot;)
		end
		send(&quot;put group sharktooth in mill&quot;, false)
		send(&quot;mill for &quot;.. inksleft ..&quot; green&quot;, false)
		inksmilled = inksneeded
	end
else
		send(&quot;get group ink from mill&quot;, false)
		send(&quot;inr all ink&quot;, false)
		echo(&quot;FINISHED MILLING\n&quot;)
		disableTimer(&quot;greenink&quot;)
end</script>
                <command></command>
                <packageName></packageName>
                <time>00:00:04.000</time>
            </Timer>
            <Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
                <name>goldink</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <time>00:00:04.000</time>
            </Timer>
        </TimerGroup>
    </TimerPackage>
    <AliasPackage>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>run-lua-code-v4</name>
            <script></script>
            <command></command>
            <packageName>run-lua-code-v4</packageName>
            <regex></regex>
            <Alias isActive="yes" isFolder="no">
                <name>run lua code</name>
                <script>local f,e = loadstring(&quot;return &quot;..matches[2])
if not f then
	f,e = assert(loadstring(matches[2]))
end

local r = f()
if r ~= nil then display(r) end</script>
                <command></command>
                <packageName></packageName>
                <regex>^lua (.*)$</regex>
            </Alias>
        </AliasGroup>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>Skills</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <regex></regex>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Tarot</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <AliasGroup isActive="yes" isFolder="yes">
                    <name>Cards</name>
                    <script></script>
                    <command></command>
                    <packageName></packageName>
                    <regex></regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>magician</name>
                        <script>send(&quot;fling magician at me&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^mgi$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>priestess</name>
                        <script>send(&quot;fling priestess at me&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^pr$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Universe</name>
                        <script>destination = matches[2]
send(&quot;fling universe at ground&quot;)
tempTimer(3.2, [[send(&quot;touch &quot; .. destination)]])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^uni (\w+)$</regex>
                    </Alias>
                    <AliasGroup isActive="yes" isFolder="yes">
                        <name>hermit</name>
                        <script></script>
                        <command></command>
                        <packageName></packageName>
                        <regex></regex>
                        <Alias isActive="yes" isFolder="no">
                            <name>Activate</name>
                            <script>send(&quot;outd hermit&quot;)
send(&quot;activate hermit&quot;)</script>
                            <command></command>
                            <packageName></packageName>
                            <regex>^hermit activate$</regex>
                        </Alias>
                        <Alias isActive="yes" isFolder="no">
                            <name>Apply</name>
                            <script>send(&quot;fling hermit at ground&quot;)</script>
                            <command></command>
                            <packageName></packageName>
                            <regex>^hermit home$</regex>
                        </Alias>
                    </AliasGroup>
                    <Alias isActive="yes" isFolder="no">
                        <name>Hiero</name>
                        <script>local tar = matches[3]
local order = matches[4]

send(&quot;outd hierophant&quot;)
send(&quot;fling hierophant at &quot; .. tar)
temptTimer(1.5, [[send(&quot;order&quot; .. tar .. &quot; &quot; .. order)]])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(H|h)iero (\w+) (.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Emperor</name>
                        <script>send(&quot;outd emperor&quot;)
send(&quot;fling emperor at &quot; .. matches[2])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^emperor (\w+)$</regex>
                    </Alias>
                </AliasGroup>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Pranks</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>HocusPocus</name>
                    <script>send(&quot;hocuspocus &quot; .. matches[2] .. &quot; colour &quot; .. matches[3] .. &quot; &quot; .. matches[4])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^hp (\d+) (\d+) (.*)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>makebomb</name>
                    <script>bombAmnt = tonumber(matches[2]) - 1
bombType = matches[3]

makeBomb()</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^makebomb (\d+) (.+)$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Tradeskills</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <AliasGroup isActive="yes" isFolder="yes">
                    <name>Remedies</name>
                    <script></script>
                    <command></command>
                    <packageName></packageName>
                    <regex></regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>Epidermal</name>
                        <script>amt = matches[3]
send(&quot;outr &quot; .. 2*amt .. &quot; kuzu&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; hawthorn&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; bloodroot&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; ginseng&quot;, false)
send(&quot;inpot &quot;.. 2*amt ..&quot; kuzu in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; hawthorn in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; bloodroot in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; ginseng in pot&quot;, false)
send(&quot;drop pot&quot;, false)
send(&quot;boil pot for epidermal&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(C|c)ook (\d) epidermal$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>immunity</name>
                        <script>amt = matches[3]
send(&quot;outr &quot;.. 2*amt ..&quot; echinacea&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; sac&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; ash&quot;, false)
send(&quot;inpot &quot;.. 2*amt ..&quot; echinacea in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; sac in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; ash in pot&quot;, false)
send(&quot;drop pot&quot;, false)
send(&quot;boil pot for immunity&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(C|c)ook (\d+) immunity$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Mending</name>
                        <script>amt = matches[3]
send(&quot;outr &quot;.. 2*amt ..&quot; ginger&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; kuzu&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; dust&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; kelp&quot;, false)
send(&quot;inpot &quot;.. 2*amt ..&quot; ginger in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; kuzu in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; dust in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; kelp in pot&quot;, false)
send(&quot;drop pot&quot;, false)
send(&quot;boil pot for mending&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(C|c)ook (\d+) mending$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Health</name>
                        <script>amt = tonumber(matches[2])
send(&quot;outr &quot;.. 1*amt ..&quot; valerian&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; goldenseal&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; myrrh&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; ginseng&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; valerian in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; goldenseal in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; myrrh in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; ginseng in pot&quot;, false)
send(&quot;drop pot&quot;, false)
send(&quot;boil pot for health&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^cook (\d+) health$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Caloric</name>
                        <script>amt = matches[2]
send(&quot;outr &quot; .. 2*amt .. &quot; kuzu&quot;, false)
send(&quot;outr &quot;.. 2*amt ..&quot; kelp&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; valerian&quot;, false)
send(&quot;outr &quot;.. 1*amt ..&quot; bellwort&quot;, false)
send(&quot;inpot &quot;.. 2*amt ..&quot; kuzu in pot&quot;, false)
send(&quot;inpot &quot;.. 2*amt ..&quot; kelp in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; valerian in pot&quot;, false)
send(&quot;inpot &quot;.. 1*amt ..&quot; bellwort in pot&quot;, false)
send(&quot;drop pot&quot;, false)
send(&quot;boil pot for caloric&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^cook (\d+) caloric$</regex>
                    </Alias>
                </AliasGroup>
                <AliasGroup isActive="yes" isFolder="yes">
                    <name>Gathering</name>
                    <script></script>
                    <command></command>
                    <packageName></packageName>
                    <regex></regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>refining</name>
                        <script>refining = matches[3]
refineAmt = matches[2]

refineIngredient()</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^refine (\d+) (\w+)$</regex>
                    </Alias>
                </AliasGroup>
                <AliasGroup isActive="yes" isFolder="yes">
                    <name>Inkmilling</name>
                    <script></script>
                    <command></command>
                    <packageName></packageName>
                    <regex></regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>Red Ink</name>
                        <script>inksmilled = 0
inksneeded = tonumber(matches[2])

enableTimer(&quot;redink&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^millfor (\d+) red$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Blue Ink</name>
                        <script>inksmilled = 0
inksneeded = tonumber(matches[2])

enableTimer(&quot;blueink&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^millfor (\d+) blue$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Yellow Ink</name>
                        <script>inksmilled = 0
inksneeded = tonumber(matches[2])

enableTimer(&quot;yellowink&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^millfor (\d+) yellow$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Green Ink</name>
                        <script>inksmilled = 0
inksneeded = tonumber(matches[2])

enableTimer(&quot;greenink&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^millfor (\d+) green$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>Purple Ink</name>
                        <script>inksmilled = 0
inksneeded = tonumber(matches[2])

enableTimer(&quot;purpleink&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^millfor (\d+) purple$</regex>
                    </Alias>
                </AliasGroup>
                <Alias isActive="yes" isFolder="no">
                    <name>Conjure Item</name>
                    <script>conjNumCreate = tonumber(matches[3])
conjToCreate = matches[4]

conjureItem(conjToCreate)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(C|c)onjure (\d+) (\w+)$</regex>
                </Alias>
            </AliasGroup>
        </AliasGroup>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>Essentials</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <regex></regex>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Stuff handling</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>get gold</name>
                    <script>expandAlias(&quot;get &quot; .. matches[3] .. &quot; gold from pack2&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(G|g)et (\d+) gold$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>put gold away</name>
                    <script>expandAlias(&quot;put gold in pack2&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(P|p)ut gold away$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>put pack2</name>
                    <script>send(&quot;put &quot; .. matches[3] .. &quot; in backpack82119&quot;, false)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(P|p)ut (.+) in pack2$</regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>p pack2</name>
                        <script>send(&quot;p backpack82119&quot;, false)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^p pack2$</regex>
                    </Alias>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>get pack2</name>
                    <script>send(&quot;get &quot; .. matches[3] .. &quot; from backpack82119&quot;, false)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(G|g)et (.+) from pack2$</regex>
                </Alias>
            </AliasGroup>
            <Alias isActive="yes" isFolder="no">
                <name>Learning</name>
                <script>lessonsLeft = tonumber(matches[2])
skill = matches[3]
instructor = matches[4]

if lessonsLeft &gt; 20 then
	send(&quot;learn 20 &quot; .. skill .. &quot; from &quot; .. instructor, false)
	lessonsLeft = lessonsLeft - 20
	echo(lessonsLeft .. &quot; remaining!\n&quot;)
else
	send(&quot;learn &quot; .. lessonsLeft .. &quot; &quot; .. skill .. &quot; from &quot; .. instructor)
end</script>
                <command></command>
                <packageName></packageName>
                <regex>^learn (\d+) (\w+) from (\w+)$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>Roulette</name>
                <script>roll = playRoulette()
send(&quot;bet &quot; .. matches[3] .. &quot; gold on&quot; .. roll, false)</script>
                <command></command>
                <packageName></packageName>
                <regex>^(R|r)oulette (\d+)$</regex>
            </Alias>
        </AliasGroup>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>Other</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <regex></regex>
            <Alias isActive="yes" isFolder="no">
                <name>castline</name>
                <script>send(&quot;bait hook with &quot; .. matches[2])
send(&quot;cast line &quot; .. matches[3])</script>
                <command></command>
                <packageName></packageName>
                <regex>^cast (\w+) (\w+)$</regex>
                <Alias isActive="yes" isFolder="no">
                    <name>reel line </name>
                    <script></script>
                    <command>reel line</command>
                    <packageName></packageName>
                    <regex>^reel$</regex>
                </Alias>
            </Alias>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>logger</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>start log</name>
                    <script>path = &quot;C:\\Users\\Wyatt\\Desktop\\Games\\Mudlet\\Notes\\&quot;

if io.exists(path .. matches[2] .. &quot;.txt&quot;) then
  echo(&quot;This file exists!&quot;)
else

	echo(&quot;Logging at: &quot; .. path .. matches[2] .. &quot;.txt&quot; .. &quot;!\n&quot;)
	file = io.open(path .. matches[2] .. &quot;.txt&quot;, &quot;w&quot;)
	enableTrigger(&quot;logging&quot;)

end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^log (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>end log</name>
                    <script>disableTrigger(&quot;logging&quot;)
echo(path .. matches[2] .. &quot;.txt&quot; .. &quot; log complete.\n&quot;)
file:close()</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^logend$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Market Stuff</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Eccentric Jester</name>
                    <script>expandAlias(&quot;get 50 gold&quot;, false)
send(&quot;market Need to blow up? Need to heal up? Need to cook up? Ingredients, herbs, elixirs and Jester services. AD 172&quot;, false)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^sell self$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>market general</name>
                    <script>local message = matches[2]

expandAlias(&quot;get 50 gold&quot;)
send(&quot;market &quot; .. message)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^mkt (.+)$</regex>
                </Alias>
            </AliasGroup>
            <Alias isActive="yes" isFolder="no">
                <name>Clear chat window</name>
                <script>clearWindow(matches[2])</script>
                <command></command>
                <packageName></packageName>
                <regex>^clear (\w+)$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>throwing</name>
                <script>send(&quot;wield &quot; .. matches[2])
send(&quot;throw &quot; .. matches[2] .. matches[3])</script>
                <command></command>
                <packageName></packageName>
                <regex>^throw (\w+)(.+)$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>Quit</name>
                <script>if quit == 0 then
	quit = 1
	raiseEvent(&quot;endGame&quot;)
end</script>
                <command></command>
                <packageName></packageName>
                <regex>^(q|Q)uit$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>Stop</name>
                <script>if quit == 1 then
	quit = 0
	raiseEvent(&quot;returnGame&quot;)
	send(&quot;stop&quot;)
else send(&quot;stop&quot;)
end</script>
                <command></command>
                <packageName></packageName>
                <regex>^(s|S)top$</regex>
            </Alias>
        </AliasGroup>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>Hunting</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <regex></regex>
            <Alias isActive="yes" isFolder="no">
                <name>Target</name>
                <script>target = matches[2]
echo(&quot;TARGET: &quot; .. target)</script>
                <command></command>
                <packageName></packageName>
                <regex>^t (\w+)$</regex>
            </Alias>
        </AliasGroup>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>emotes</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <regex></regex>
            <Alias isActive="yes" isFolder="no">
                <name>sit</name>
                <script></script>
                <command>sit: sits upon the ground, crossing his legs in one smooth motion</command>
                <packageName></packageName>
                <regex>^sit$</regex>
                <Alias isActive="yes" isFolder="no">
                    <name>sit pedestal</name>
                    <script></script>
                    <command>sit pedestal: (Amid a rustle of feathers,) lands gently atop @thing</command>
                    <packageName></packageName>
                    <regex>^sit pedestal$</regex>
                </Alias>
            </Alias>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Tuko</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Tukopuff</name>
                    <script>send(&quot;hocuspocus 1 A winged lizard of verdant green snorts in amusement, small green clouds puffing from his nostrils.&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(T|t)ukopuff$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Tukonarrow</name>
                    <script>send(&quot;emote (@tuko turns his attention to), narrowing his eyes.&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(T|t)ukonarrow$</regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>^[tT]ukonarrow .+$</name>
                        <script>send(&quot;emote (Peering over) 's shoulder, @tuko warily narrows his eyes at @&quot; .. matches[2])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^[tT]ukonarrow (.+)$</regex>
                    </Alias>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Tukodrop</name>
                    <script>send(&quot;drop tuko: (@thing peeks out from @pack briefly, before emerging and crawling sinuously out and onto) 's shoulder&quot;)
send(&quot;order tuko follow me&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^drop tuko$</regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>Tukoget</name>
                        <script>send(&quot;get tuko: (@thing crawls into @pack,) wincing visibly as the lizard's claws inadvertently dig into his flesh&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^get tuko$</regex>
                    </Alias>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Lonraigh</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex>^drop lonraigh$</regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Lonraighdrop</name>
                    <script>send(&quot;drop lonraigh:(dropping from a nearby perch, @thing lands near), preening himself nonchalantly&quot;)
send(&quot;order lonraigh follow me&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^drop lonraigh$</regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>Lonraighget</name>
                        <script></script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^get lonraigh$</regex>
                    </Alias>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Finte</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Fintedrop</name>
                    <script>send(&quot;drop finte: (A soft peeping is heard shortly before @thing totters out from behind), looking about curiously&quot;)
send(&quot;order finte follow me&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^drop finte$</regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>Finteget</name>
                        <script>send(&quot;get finte: (@thing cheeps at) before wandering off to explore&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^get finte$</regex>
                    </Alias>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Feith</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Feithdrop</name>
                    <script>send(&quot;drop feith: (Appearing out of nowhere, @thing crawls into view upon) 's chest&quot;)
send(&quot;order feith follow me&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^drop (mantis|feith)$</regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>Feithget</name>
                        <script>send(&quot;get feith: (eluding) 's attempts to grab him, @thing crawls out of view, hiding upon him.&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^get (feith|mantis)$</regex>
                    </Alias>
                </Alias>
            </AliasGroup>
        </AliasGroup>
        <Alias isActive="yes" isFolder="no">
            <name>Refine materials</name>
            <script>--send(&quot;touch shield&quot;)
torefine = matches[3]
refinesleft = tonumber(matches[2]) - 100
echo(&quot;refining &quot; .. refinesleft .. &quot; &quot; .. torefine .. &quot;\n&quot;)
send(&quot;REFINE 100 &quot; .. torefine)</script>
            <command></command>
            <packageName></packageName>
            <regex>^REFINE (\d+) (\w+)$</regex>
        </Alias>
        <Alias isActive="yes" isFolder="no">
            <name>clearwindow</name>
            <script>window = matches[2]

if window == &quot;city&quot; then
	
elseif window == &quot;house&quot; then
	
elseif window == &quot;clans&quot; then

elseif window == &quot;tells&quot; then

elseif window == &quot;party&quot; then

end</script>
            <command></command>
            <packageName></packageName>
            <regex>^clearwindow (.+)$</regex>
        </Alias>
    </AliasPackage>
    <ActionPackage/>
    <ScriptPackage>
        <Script isActive="yes" isFolder="no">
            <name>KEEP ON TOP</name>
            <packageName></packageName>
            <script>----------------------------------------------------------------------------------
--- Mudlet DB
----------------------------------------------------------------------------------


-- TODO will be already loaded in LuaGlobal
-----------------------------------------------------------------------------
-- General-purpose useful tools that were needed during development:
-----------------------------------------------------------------------------
if package.loaded[&quot;rex_pcre&quot;] then rex = require&quot;rex_pcre&quot; end

if not display then require&quot;DebugTools&quot; end
if not table.contains then require&quot;TableUtils&quot; end
if not string.trim then require&quot;StringUtils&quot; end

-- TODO those funciton are already definde elsewhere
-- Tests if a table is empty: this is useful in situations where you find
-- yourself wanting to do 'if my_table == {}' and such.
function table.is_empty(tbl)
   return next(tbl) == nil
end

function string.starts(String,Start)
   return string.sub(String,1,string.len(Start))==Start
end

function string.ends(String,End)
   return End=='' or string.sub(String,-string.len(End))==End
end




-- TODO move to StringUtils?
-----------------------------------------------------------------------------
-- Some Date / Time parsing functions.
-----------------------------------------------------------------------------
datetime = {
   _directives = {
      [&quot;%b&quot;] = &quot;(?P&lt;abbrev_month_name&gt;jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)&quot;,
      [&quot;%B&quot;] = &quot;(?P&lt;month_name&gt;january|febuary|march|april|may|june|july|august|september|october|november|december)&quot;,
      [&quot;%d&quot;] = &quot;(?P&lt;day_of_month&gt;\\d{2})&quot;,
      [&quot;%H&quot;] = &quot;(?P&lt;hour_24&gt;\\d{2})&quot;,
      [&quot;%I&quot;] = &quot;(?P&lt;hour_12&gt;\\d{2})&quot;,
      [&quot;%m&quot;] = &quot;(?P&lt;month&gt;\\d{2})&quot;,
      [&quot;%M&quot;] = &quot;(?P&lt;minute&gt;\\d{2})&quot;,
      [&quot;%p&quot;] = &quot;(?P&lt;ampm&gt;am|pm)&quot;,
      [&quot;%S&quot;] = &quot;(?P&lt;second&gt;\\d{2})&quot;,
      [&quot;%y&quot;] = &quot;(?P&lt;year_half&gt;\\d{2})&quot;,
      [&quot;%Y&quot;] = &quot;(?P&lt;year_full&gt;\\d{4})&quot;
   },
   _pattern_cache = {},
   _month_names = {
      [&quot;january&quot;] = 1,
      [&quot;febuary&quot;] = 2,
      [&quot;march&quot;] = 3,
      [&quot;april&quot;] = 4,
      [&quot;may&quot;] = 5,
      [&quot;june&quot;] = 6,
      [&quot;july&quot;] = 7,
      [&quot;august&quot;] = 8,
      [&quot;september&quot;] = 9,
      [&quot;october&quot;] = 10,
      [&quot;november&quot;] = 11,
      [&quot;december&quot;] = 12
   },
   _abbrev_month_names = {
      [&quot;jan&quot;] = 1,
      [&quot;feb&quot;] = 2,
      [&quot;mar&quot;] = 3,
      [&quot;apr&quot;] = 4,
      [&quot;may&quot;] = 5,
      [&quot;jun&quot;] = 6,
      [&quot;jul&quot;]= 7,
      [&quot;aug&quot;]= 8,
      [&quot;sep&quot;] = 9,
      [&quot;oct&quot;] = 10,
      [&quot;nov&quot;] = 11,
      [&quot;dec&quot;] = 12
   }
}

-- the timestamp is stored in UTC time, so work out the difference in seconds
-- from local to UTC time. Credit: https://github.com/stevedonovan/Penlight/blob/master/lua/pl/Date.lua#L85
function datetime:calculate_UTCdiff(ts)
   local date, time = os.date, os.time
   local utc = date('!*t',ts)
   local lcl = date('*t',ts)
   lcl.isdst = false
   return os.difftime(time(lcl), time(utc))
end

-- NOT LUADOC
-- The rex.match function does not return named patterns even if you use named capture
-- groups, but the r:tfind does -- but this only operates on compiled patterns. So,
-- we are caching the conversion of 'simple format' date patterns into a regex, and
-- then compiling them.
function datetime:_get_pattern(format)
   if not datetime._pattern_cache[format] then
      local fmt = rex.gsub(format, &quot;(%[A-Za-z])&quot;,
         function(m)
               return datetime._directives[m] or m
         end
         )

      datetime._pattern_cache[format] = rex.new(fmt, rex.flags().CASELESS)
   end

   return datetime._pattern_cache[format]
end



--- Parses the specified source string, according to the format if given, to return a representation of
--- the date/time. The default format if not specified is: &quot;^%Y-%m-%d %H:%M:%S$&quot; &lt;br/&gt;&lt;br/&gt;
---
--- If as_epoch is provided and true, the return value will be a Unix epoch -- the number
--- of seconds since 1970. This is a useful format for exchanging date/times with other systems. If as_epoch
--- is false, then a Lua time table will be returned. Details of the time tables are provided
--- in the http://www.lua.org/pil/22.1.html. &lt;br/&gt;&lt;br/&gt;
---
--- Supported Format Codes
---   &lt;/pre&gt;
---   %b   Abbreviated Month Name
---   %B   Full Month Name
---   %d   Day of Month
---   %H   Hour (24-hour format)
---   %I   Hour (12-hour format, requires %p as well)
---   %p   AM or PM
---   %m   2-digit month (01-12)
---   %M   2-digit minutes (00-59)
---   %S   2-digit seconds (00-59)
---   %y   2-digit year (00-99), will automatically prepend 20 so 10 becomes 2010 and not 1910.
---   %Y   4-digit year.
---   &lt;/pre&gt;
function datetime:parse(source, format, as_epoch)
   if not format then
      format = &quot;^%Y-%m-%d %H:%M:%S$&quot;
   end

   local fmt = datetime:_get_pattern(format)
   local m = {fmt:tfind(source)}

   if m and m[3] then
      m = m[3]
      dt = {}

      if m.year_half then
         dt.year = tonumber(&quot;20&quot;..m.year_half)
      elseif m.year_full then
         dt.year = tonumber(m.year_full)
      end

      if m.month then
         dt.month = tonumber(m.month)
      elseif m.month_name then
         dt.month = datetime._month_names[m.month_name:lower()]
      elseif m.abbrev_month_name then
         dt.month = datetime._abbrev_month_names[m.abbrev_month_name:lower()]
      end

      dt.day = m.day_of_month

      if m.hour_12 then
         assert(m.ampm, &quot;You must use %p (AM|PM) with %I (12-hour time)&quot;)
         if m.ampm == &quot;PM&quot; then
            dt.hour = 12 + tonumber(m.hour_12)
         else
            dt.hour = tonumber(m.hour_12)
         end
      else
         dt.hour = tonumber(m.hour_24)
      end

      dt.min = tonumber(m.minute)
      dt.sec = tonumber(m.second)
      dt.isdst = false

      if as_epoch then
         return os.time(dt)
      else
         return dt
      end
   else
      return nil
   end
end



-----------------------------------------------------------------------------
-- The database wrapper library
-----------------------------------------------------------------------------
if package.loaded[&quot;luasql.sqlite3&quot;] then luasql = require &quot;luasql.sqlite3&quot; end

db = {}
db.__autocommit = {}
db.__schema = {}
db.__conn = {}

db.debug_sql = false



-- NOT LUADOC
-- Converts the type of a lua object to the equivalent type in SQL
function db:_sql_type(value)
   local t = type(value)

   if t == &quot;number&quot; then
      return &quot;REAL&quot;
   elseif t == &quot;nil&quot; then
      return &quot;NULL&quot;
   elseif t == &quot;table&quot; and value._timestamp ~= nil then
      return &quot;INTEGER&quot;
   else
      return &quot;TEXT&quot;
   end
end



-- NOT LUADOC
-- Converts a data value in Lua to its SQL equivalent; notably it will also escape single-quotes to
-- prevent inadvertant SQL injection.
-- called when generating the schema
function db:_sql_convert(value)
   local t = db:_sql_type(value)

   if value == nil then
      return &quot;NULL&quot;
   elseif t == &quot;TEXT&quot; and type(value) == &quot;string&quot; then
      return '&quot;'..value:gsub(&quot;'&quot;, &quot;''&quot;)..'&quot;'
   elseif t == &quot;NULL&quot; then
      return &quot;NULL&quot;
   elseif t == &quot;INTEGER&quot; then
      -- With db.Timestamp's, a value of false should be interpreted as nil.
      if value._timestamp == false then
         return &quot;NULL&quot;
      end
      return tostring(value._timestamp)
   else
      return tostring(value)
   end
end



-- NOT LUADOC
-- Given a sheet name and the details of an index, this function will return a unique index name to
-- add to the database. The purpose of this is to create unique index names as indexes are tested
-- for existance on each call of db:create and not only on creation. That way new indexes can be
-- added after initial creation.
function db:_index_name(tbl_name, params)
   local t = type(params)

   if t == &quot;string&quot; then
      return &quot;idx_&quot; .. tbl_name .. &quot;_c_&quot; .. params
   elseif assert(t == &quot;table&quot;, &quot;Indexes must be either a string or a table.&quot;) then
      local parts = {&quot;idx&quot;, tbl_name, &quot;c&quot;}
      for _, v in pairs(params) do
         parts[#parts+1] = v
      end
      return table.concat(parts, &quot;_&quot;)
   end
end



-- NOT LUADOC
-- This function returns true if all of the columns referenced in index_columns also exist within
-- the sheet_columns table array. The purpose of this is to raise an error if someone tries to index
-- a column which doesn't currently exist in the schema.
function db:_index_valid(sheet_columns, index_columns)
   if type(index_columns) == &quot;string&quot; then
      if sheet_columns[index_columns] ~= nil then
         return true
      else
         return false
      end
   else
      for _, v in ipairs(index_columns) do
         if sheet_columns[v] == nil then
            db:echo_sql(&quot;\n--&gt; Bad index &quot;..v)
            return false
         end
      end
   end
   return true
end



-- NOT LUADOC
-- The column_spec is either a string or an indexed table. This function returns either &quot;column&quot; or
-- &quot;column1&quot;, &quot;column2&quot; for use in the column specification of INSERT.
function db:_sql_columns(value)
   local colstr = ''
   local t = type(value)

   if t == &quot;table&quot; then
      col_chunks = {}
      for _, v in ipairs(value) do
         -- see https://www.sqlite.org/syntaxdiagrams.html#ordering-term
         if v:lower() == &quot;desc&quot; or v:lower() == &quot;asc&quot; then
            col_chunks[#col_chunks] = col_chunks[#col_chunks] .. &quot; &quot; .. v
         else
            col_chunks[#col_chunks+1] = '&quot;'..v:lower()..'&quot;'
         end
      end

      colstr = table.concat(col_chunks, ',')
   elseif assert(t == &quot;string&quot;,
         &quot;Must specify either a table array or string for index, not &quot;..type(value)) then
      colstr = '&quot;'..value:lower()..'&quot;'
   end
   return colstr
end



-- NOT LUADOC
-- This serves as a very similar function to db:_sql_columns, quoting column names properly but for
-- uses outside of INSERTs.
function db:_sql_fields(values)
   local sql_fields = {}

   for k, v in pairs(values) do
      sql_fields[#sql_fields+1] = '&quot;'..k..'&quot;'
   end

   return   &quot;(&quot;..table.concat(sql_fields, &quot;,&quot;)..&quot;)&quot;
end



-- NOT LUADOC
-- This quotes values to be passed into an INSERT or UPDATE operation in a SQL list. Meaning, it turns
-- {x=&quot;this&quot;, y=&quot;that&quot;, z=1} into ('this', 'that', 1).
-- It is intelligent with data-types; strings are automatically quoted (with internal single quotes
-- escaped), nil turned into NULL, timestamps converted to integers, and such.
function db:_sql_values(values)
   local sql_values = {}

   for k, v in pairs(values) do
      local t = type(v)
      local s = &quot;&quot;

      if t == &quot;string&quot; then
         s = &quot;'&quot;..v:gsub(&quot;'&quot;, &quot;''&quot;)..&quot;'&quot;
      elseif t == &quot;nil&quot; then
         s = &quot;NULL&quot;
      elseif t == &quot;table&quot; and t._timestamp ~= nil then
         if not t._timestamp then
            return &quot;NULL&quot;
         else
            s = &quot;datetime('&quot;..t._timestamp..&quot;', 'unixepoch')&quot;
         end
      else
         s = tostring(v)
      end

      sql_values[#sql_values+1] = s
   end

   return &quot;(&quot;..table.concat(sql_values, &quot;,&quot;)..&quot;)&quot;
end



--- &lt;b&gt;&lt;u&gt;TODO&lt;/u&gt;&lt;/b&gt; db:safe_name(name)
--   On a filesystem level, names are restricted to being alphanumeric only. So, &quot;my_database&quot; becomes
--   &quot;mydatabase&quot;, and &quot;../../../../etc/passwd&quot; becomes &quot;etcpasswd&quot;. This prevents any possible
--   security issues with database names.
function db:safe_name(name)
   name = name:gsub(&quot;[^%ad]&quot;, &quot;&quot;)
   name = name:lower()
   return name
end



--- Creates and/or modifies an existing database. This function is safe to define at a top-level of a Mudlet
--- script: in fact it is reccommended you run this function at a top-level without any kind of guards.
--- If the named database does not exist it will create it. If the database does exist then it will add
--- any columns or indexes which didn't exist before to that database. If the database already has all the
--- specified columns and indexes, it will do nothing. &lt;br/&gt;&lt;br/&gt;
---
--- The database will be called Database_&lt;sanitized database name&gt;.db and will be stored in the
--- Mudlet configuration directory. &lt;br/&gt;&lt;br/&gt;
---
--- Database 'tables' are called 'sheets' consistently throughout this documentation, to avoid confusion
--- with Lua tables. &lt;br/&gt;&lt;br/&gt;
---
--- The schema table must be a Lua table array containing table dictionaries that define the structure and
--- layout of each sheet. &lt;br/&gt;&lt;br/&gt;
---
--- For sheets with unique indexes, you may specify a _violations key to indicate how the db layer handle
--- cases where the unique index is violated. The options you may use are:
---   &lt;pre&gt;
---   FAIL - the default. A hard error is thrown, cancelling the script.
---   IGNORE - The command that would add a record that violates uniqueness just fails silently.
---   REPLACE - The old record which matched the unique index is dropped, and the new one is added to replace it.
---   &lt;/pre&gt;
---
--- @usage Example bellow will create a database with two sheets; the first is kills and is used to track every successful kill,
---   with both where and when the kill happened. It has one index, a compound index tracking the combination of name and area.
---   The second sheet has two indexes, but one is unique: it isn't possible to add two items to the enemies sheet with the same name.
---   &lt;pre&gt;
---   local mydb = db:create(&quot;combat_log&quot;,
---     {
---       kills = {
---         name = &quot;&quot;,
---         area = &quot;&quot;,
---         killed = db:Timestamp(&quot;CURRENT_TIMESTAMP&quot;),
---         _index = {{&quot;name&quot;, &quot;area&quot;}}
---       },
---       enemies = {
---         name = &quot;&quot;,
---         city = &quot;&quot;,
---         reason = &quot;&quot;,
---         enemied = db:Timestamp(&quot;CURRENT_TIMESTAMP&quot;),
---         _index = { &quot;city&quot; },
---         _unique = { &quot;name&quot; },
---         _violations = &quot;IGNORE&quot;
---       }
---     }
---   )
---   &lt;/pre&gt;
---   Note that you have to use double {{ }} if you have composite index/unique constrain.
function db:create(db_name, sheets)
   if not db.__env then
      db.__env = luasql.sqlite3()
   end

   db_name = db:safe_name(db_name)

   if not db.__conn[db_name] then
      db.__conn[db_name] = db.__env:connect(getMudletHomeDir() .. &quot;/Database_&quot; .. db_name .. &quot;.db&quot;)
      db.__conn[db_name]:setautocommit(false)
      db.__autocommit[db_name] = true
   end

   db.__schema[db_name] = {}

   -- We need to separate the actual column configuration from the meta-configuration of the desired
   -- sheet. {sheet={&quot;column&quot;}} verses {sheet={&quot;column&quot;}, _index={&quot;column&quot;}}. In the former we are
   -- creating a database with a single field; in the latter we are also adding an index on that
   -- field. The db package reserves any key that begins with an underscore to be special and syntax
   -- for its own use.
   for s_name, sht in pairs(sheets) do
      options = {}

      if sht[1] ~= nil then         -- in case the sheet was provided in the sheet = {&quot;column1&quot;, &quot;column2&quot;} format:
         local t = {}               --   assume field types are text, and should default to &quot;&quot;
         for k, v in pairs(sht) do
            t[v] = &quot;&quot;
         end
         sht = t
      else                          -- sheet provided in the sheet = {&quot;column1&quot; = default} format
         local opts = {}
         for k, v in pairs(sht) do
            if string.starts(k, &quot;_&quot;) then
               options[k] = v
               opts[#opts + 1] = k
            end
         end
         for _, v in ipairs(opts) do
            sht[v] = nil
         end
      end

      if not options._violations then
         options._violations = &quot;FAIL&quot;
      end

      db.__schema[db_name][s_name] = {columns=sht, options=options}
      db:_migrate(db_name, s_name)
   end
   return db:get_database(db_name)
end



-- NOT LUADOC
-- The migrate function is meant to upgrade an existing database live, to maintain a consistant
-- and correct set of sheets and fields, along with their indexes. It should be safe to run
-- at any time, and must not cause any data loss. It simply adds to what is there: in perticular
-- it is not capable of removing indexes, columns, or sheets after they have been defined.
function db:_migrate(db_name, s_name)
   local conn = db.__conn[db_name]
   local schema = db.__schema[db_name][s_name]

   local current_columns = {}

   -- The PRAGMA table_info command is a query which returns all of the columns currently
   -- defined in the specified table. The purpose of this section is to see if any new columns
   -- have been added.
   local cur = conn:execute(&quot;PRAGMA table_info('&quot;..s_name..&quot;')&quot;) -- currently broken - LuaSQL bug, needs to be upgraded for new sqlite API

   if type(cur) ~= &quot;number&quot; then
      local row = cur:fetch({}, &quot;a&quot;)
      if row then
         while row do
            current_columns[row.name] = row.type
            row = cur:fetch({}, &quot;a&quot;)
         end
      else
         ---------------  GETS ALL COLUMNS FROM SHEET IF IT EXISTS
         db:echo_sql(&quot;SELECT * FROM &quot;..s_name)
         local get_sheet_cur = conn:execute(&quot;SELECT * FROM &quot;..s_name)  -- select the sheet

         if get_sheet_cur and get_sheet_cur ~= 0 then
            local row = get_sheet_cur:fetch({}, &quot;a&quot;) -- grab the first row, if any
            if not row then -- if no first row then
               local tried_cols, contains, found_something, col = {}, table.contains, false

               while not found_something do -- guarded by the error below from infinite looping
                  col = false
                  for k,v in pairs(schema.columns) do -- look through sheet schema to find the first column that is text
                     if type(k) == &quot;number&quot; then
                        if string.sub(v,1,1) ~= &quot;_&quot; and not contains(tried_cols, v) then col = v break end
                     else
                        if string.sub(k,1,1) ~= &quot;_&quot; and type(v) == &quot;string&quot; and not contains(tried_cols, k) then col = k break end
                     end
                  end

                  if not col then error(&quot;db:_migrate: cannot find a suitable column for testing a new row with.&quot;) end

                  -- add row with found column set as &quot;test&quot;
                  db:add({_db_name = db_name, _sht_name = s_name},{[col] = &quot;test&quot;})

                  db:echo_sql(&quot;SELECT * FROM &quot;..s_name)
                  local get_row_cur = conn:execute(&quot;SELECT * FROM &quot;..s_name) -- select the sheet
                  row = get_row_cur:fetch({}, &quot;a&quot;) -- grab the newly created row
                  get_row_cur:close()

                  -- delete the newly created row. If we picked a row that doesn't exist yet and we're
                  -- trying to add, the delete will fail - remember this, and try another row
                  local worked, msg = pcall(db.delete, db, {_db_name = db_name, _sht_name = s_name},db:eq({database = db_name, sheet = s_name, name = col, type = &quot;string&quot;},&quot;test&quot;))

                  if not worked then
                     tried_cols[#tried_cols+1] = col
                  else
                     found_something = true
                  end
               end
            end

            if row then -- add each column from row to current_columns table
               for k,v in pairs(row) do
                  current_columns[k] = &quot;&quot;
               end
            end
            get_sheet_cur:close()
         end
      end
   end

   if type(cur) == &quot;userdata&quot; then
      cur:close()
   end

   -- The SQL definition of a column is:
   --    &quot;column_name&quot; column_type NULL
   -- The db module does not presently support columns that are required. Everything is optional,
   -- everything may be NULL / nil.
   -- If you specify a column's type, you also specify its default value.
   if table.is_empty(current_columns) then
      -- At this point, we know that the specified table does not exist in the database and so we
      -- should create it.

      -- Every sheet has an implicit _row_id column. It is not presently (and likely never will be)
      -- supported to define the primary key of any sheet.
      local sql = db:_build_create_table_sql(schema, s_name)
      db:echo_sql(sql)
      conn:execute(sql)

   else
      -- At this point we know that the sheet already exists, but we are concerned if the current
      -- definition includes columns which may be added.
      local missing = {}

      for k, v in pairs(schema.columns) do

         -- Here we test it a given column exists in the sheet already, and if not, we add that
         -- column.
         if not current_columns[k] then
            missing[#missing + 1] = { name = k, default = v }
         end
      end

      if #missing &gt; 0 and 
         table.size(current_columns) + #missing == table.size(schema.columns)+1
         -- We have changes and when we did those changes, we have exactly
         -- the number of columns we need. The &quot;+1&quot; is for the _row_id
         -- which is not in the schema.
      then
         local sql_add = 'ALTER TABLE %s ADD COLUMN &quot;%s&quot; %s NULL DEFAULT %s'
         for _, v in ipairs(missing) do
            local t = db:_sql_type(v.default)
            local def = db:_sql_convert(v.default)
            local sql = sql_add:format(s_name, v.name, t, def)
            conn:execute(sql)
            db:echo_sql(sql)
         end
      elseif 
         #missing + table.size(current_columns) &gt; table.size(schema.columns) + 1
         -- if we add all missing columns and we have more columns than we want
         -- then there are currently some columns we don't want anymore.
      then
         local get_create = &quot;SELECT sql FROM sqlite_master &quot; ..
                            &quot;WHERE type = 'table' AND &quot; ..
                            &quot;name = '&quot; .. s_name ..&quot;'&quot;
         local ret_str
         cur, ret_str = conn:execute(get_create)
         assert(cur, ret_str)
         if type(cur) ~= &quot;number&quot; then
            local row = cur:fetch({}, &quot;a&quot;);
            cur:close()
            local create_tmp = row.sql:gsub(s_name, s_name .. &quot;_bak&quot;)
            local sql_chunks = {}
            local fields = { &quot;_row_id&quot; }
            local sql

            create_tmp = create_tmp:gsub(&quot;TABLE&quot;, &quot;TEMPORARY TABLE&quot;)

            for k, _ in pairs(schema.columns) do
              fields[#fields + 1] = string.format('&quot;%s&quot;', k)
            end
            local fields_sql = table.concat(fields, &quot;, &quot;)

            sql_chunks[#sql_chunks + 1] = create_tmp .. &quot;;&quot;
            sql_chunks[#sql_chunks + 1] = &quot;INSERT INTO &quot; .. s_name .. &quot;_bak &quot; ..
                                          &quot;SELECT * FROM &quot; .. s_name .. &quot;;&quot;
            sql_chunks[#sql_chunks + 1] = &quot;DROP TABLE &quot; .. s_name .. &quot;;&quot;
            sql_chunks[#sql_chunks + 1] = db:_build_create_table_sql(schema,
                                               s_name) .. &quot;;&quot;
            sql_chunks[#sql_chunks + 1] = string.format(
                 &quot;INSERT INTO %s SELECT %s FROM %s_bak;&quot;, s_name, fields_sql,
                 s_name)
            sql_chunks[#sql_chunks + 1] = &quot;DROP TABLE &quot; .. s_name .. &quot;_bak;&quot;

            for _, sql in ipairs(sql_chunks) do
               db:echo_sql(sql)
               local ret, str = conn:execute(sql)
               assert(ret, str)
            end
         end
      end
   end

   -- On every invocation of db:create we run the code that creates indexes, as that code will
   -- do nothing if the specific indexes already exist. This is enforced by the db:_index_name
   -- function creating a unique index.
   --
   -- Note that in no situation will an existing index be deleted.

   -- make up current_columns, as pragma_info currently does not populate it, due to luasql bug
   for key, value in pairs(schema.columns) do
      current_columns[key] =  db:_sql_type(value)
   end

   db:_migrate_indexes(conn, s_name, schema, current_columns)
   db:echo_sql(&quot;COMMIT&quot;)
   conn:commit()
   conn:execute(&quot;VACUUM&quot;)
end

function db:_build_create_table_sql(schema, s_name)

   local sql_column = ', &quot;%s&quot; %s NULL'
   local sql_column_default = sql_column..' DEFAULT %s'


   local sql_chunks = {&quot;CREATE TABLE &quot;, s_name,  '(&quot;_row_id&quot; INTEGER PRIMARY KEY AUTOINCREMENT'}

      -- We iterate over every defined column, and add a line which creates it.
   for key, value in pairs(schema.columns) do
      local sql = &quot;&quot;
      if value == nil then
         sql = sql_column:format(key, db:_sql_type(value))
      else
         sql = sql_column_default:format(key, db:_sql_type(value), db:_sql_convert(value))
      end
      if (type(schema.options._unique) == &quot;table&quot; and table.contains(schema.options._unique, key))
         or (type(schema.options._unique) == &quot;string&quot; and schema.options._unique == key) then
         sql = sql .. &quot; UNIQUE&quot;
      end
      sql_chunks[#sql_chunks+1] = sql
   end

   sql_chunks[#sql_chunks+1] = &quot;)&quot;

   return table.concat(sql_chunks, &quot;&quot;)
end


-- NOT LUADOC
-- Creates any indexes which do not yet exist in the given database.
function db:_migrate_indexes(conn, s_name, schema, current_columns)
   local sql_create_index = &quot;CREATE %s IF NOT EXISTS %s ON %s (%s);&quot;
   local opt = {_unique = &quot;UNIQUE INDEX&quot;, _index = &quot;INDEX&quot;} -- , _check = &quot;CHECK&quot;}

   for option_type, options in pairs(schema.options) do
      if option_type == &quot;_unique&quot; or option_type == &quot;_index&quot; then
         for _, value in pairs(options) do

            -- If an index references a column which does not presently exist within the schema
            -- this will fail.

            if db:_index_valid(current_columns, value) then
               --assert(db:_index_valid(current_columns, value),
               --      &quot;In sheet &quot;..s_name..&quot; an index field is specified that does not exist.&quot;)

               local sql = sql_create_index:format(
                     opt[option_type], db:_index_name(s_name, value), s_name, db:_sql_columns(value)
               )
               db:echo_sql(sql)
               conn:execute(sql)
            end
         end
      end
   end
end



--- Adds one or more new rows to the specified sheet. If any of these rows would violate a UNIQUE index,
--- a lua error will be thrown and execution will cancel. As such it is advisable that if you use a UNIQUE
--- index, you test those values before you attempt to insert a new row. &lt;br/&gt;&lt;br/&gt;
---
--- Each table is a series of key-value pairs to set the values of the sheet, but if any keys do not exist
--- then they will be set to nil or the default value. As you can see, all fields are optional.
---
--- @usage Adding one record.
---   &lt;pre&gt;
---   db:add(mydb.enemies, {name=&quot;Bob Smith&quot;, city=&quot;San Francisco&quot;})
---   &lt;/pre&gt;
--- @usage Adding multiple records.
---   &lt;pre&gt;
---   db:add(mydb.enemies,
---     {name=&quot;John Smith&quot;, city=&quot;San Francisco&quot;},
---     {name=&quot;Jane Smith&quot;, city=&quot;San Francisco&quot;},
---     {name=&quot;Richard Clark&quot;}
---   )
---   &lt;/pre&gt;
function db:add(sheet, ...)
   local db_name = sheet._db_name
   local s_name = sheet._sht_name
   assert(s_name, &quot;First argument to db:add must be a proper Sheet object.&quot;)

   local conn = db.__conn[db_name]
   local sql_insert = &quot;INSERT OR %s INTO %s %s VALUES %s&quot;

   for _, t in ipairs({...}) do
      if t._row_id then
         -- You are not permitted to change a _row_id
         t._row_id = nil
      end

      local sql = sql_insert:format(db.__schema[db_name][s_name].options._violations, s_name, db:_sql_fields(t), db:_sql_values(t))
      db:echo_sql(sql)

      local result, msg = conn:execute(sql)
      if not result then return nil, msg end
   end
   if db.__autocommit[db_name] then
      conn:commit()
   end
   return true
end



--- Execute SQL select query against database. This only useful for some very specific cases. &lt;br/&gt;
--- Use db:fetch if possible instead - this function should not be normally used!
---
--- @release post Mudlet 1.1.1 (&lt;b&gt;&lt;u&gt;TODO update before release&lt;/u&gt;&lt;/b&gt;)
---
--- @usage Following will select all distinct area from my kills DB.
---   &lt;pre&gt;
---   db:fetch_sql(mydb.kills, &quot;SELECT distinct area FROM kills&quot;)
---   &lt;/pre&gt;
---
--- @see db:fetch
function db:fetch_sql(sheet, sql)
   local db_name = sheet._db_name
   local conn = db.__conn[db_name]

   db:echo_sql(sql)
   local cur = conn:execute(sql)

   -- if we had a syntax error in our SQL, cur will be nil
   if cur and cur ~= 0 then
      local results = {}
      local row = cur:fetch({}, &quot;a&quot;)

      while row do
         results[#results+1] = db:_coerce_sheet(sheet, row)
         row = cur:fetch({}, &quot;a&quot;)
      end
      cur:close()
      return results
   else
      return nil
   end
end



--- Returns a table array containing a table for each matching row in the specified sheet. All arguments
--- but sheet are optional. If query is nil, the entire contents of the sheet will be returned. &lt;br/&gt;&lt;br/&gt;
---
--- Query is a string which should be built by calling the various db: expression functions, such as db:eq,
--- db:AND, and such. You may pass a SQL WHERE clause here if you wish, but doing so is very dangerous.
--- If you don't know SQL well, its best to build the expression.&lt;br/&gt;&lt;br/&gt;
---
--- Query may also be a table array of such expressions, if so they will be AND'd together implicitly.&lt;br/&gt;&lt;br/&gt;
---
--- The results that are returned are not in any guaranteed order, though they are usually the same order
--- as the records were inserted. If you want to rely on the order in any way, you must pass a value to the
--- order_by field. This must be a table array listing the fields you want to sort by.
--- It can be { mydb.kills.area }, or { mydb.kills.area, mydb.kills.name } &lt;br/&gt;&lt;br/&gt;
---
--- The results are returned in ascending (smallest to largest) order; to reverse this pass true into the final field.
---
--- @usage The first will fetch all of your enemies, sorted first by the city they reside in and then by their name.
---   &lt;pre&gt;
---   db:fetch(mydb.enemies, nil, {mydb.enemies.city, mydb.enemies.name})
---   &lt;/pre&gt;
--- @usage The second will fetch only the enemies which are in San Francisco.
---   &lt;pre&gt;
---   db:fetch(mydb.enemies, db:eq(mydb.enemies.city, &quot;San Francisco&quot;))
---   &lt;/pre&gt;
--- @usage The third will fetch all the things you've killed in Undervault which have Drow in their name.
---   &lt;pre&gt;
---   db:fetch(mydb.kills,
---      {
---         db:eq(mydb.kills.area, &quot;Undervault&quot;),
---         db:like(mydb.kills.name, &quot;%Drow%&quot;)
---      }
---   )
---   &lt;/pre&gt;
---
--- @see db:fetch_sql
function db:fetch(sheet, query, order_by, descending)
   local s_name = sheet._sht_name

   local sql = &quot;SELECT * FROM &quot;..s_name

   if query then
      if type(query) == &quot;table&quot; then
         sql = sql..&quot; WHERE &quot;..db:AND(unpack(query))
      else
         sql = sql..&quot; WHERE &quot;..query
      end
   end

   if order_by then
      local o = {}
      for _, v in ipairs(order_by) do
         assert(v.name, &quot;You must pass field instances (as obtained from yourdb.yoursheet.yourfield) to sort.&quot;)
         o[#o+1] = v.name

         if descending then
            o[#o+1] = &quot;DESC&quot;
         end
      end

      sql = sql..&quot; ORDER BY &quot;..db:_sql_columns(o)
   end

   return db:fetch_sql(sheet, sql)
end



--- Returns the result of calling the specified aggregate function on the field and its sheet. &lt;br/&gt;&lt;br/&gt;
---
--- The supported aggregate functions are:
---   &lt;pre&gt;
---   COUNT - Returns the total number of records that are in the sheet or match the query.
---   AVG   - Returns the average of all the numbers in the specified field.
---   MAX   - Returns the highest number in the specified field.
---   MIN   - Returns the lowest number in the specified field.
---   TOTAL - Returns the value of adding all the contents of the specified field.
---   &lt;/pre&gt;
---
--- @param query optional
---
--- @usage Example:
---   &lt;pre&gt;
---   local mydb = db:get_database(&quot;my database&quot;)
---   echo(db:aggregate(mydb.enemies.name, &quot;count&quot;))
---   &lt;/pre&gt;
function db:aggregate(field, fn, query, distinct)
   local db_name = field.database
   local s_name = field.sheet
   local conn = db.__conn[db_name]

   assert(type(field) == &quot;table&quot;, &quot;Field must be a field reference.&quot;)
   assert(field.name, &quot;Field must be a real field reference.&quot;)

   local sql_chunks = {&quot;SELECT&quot;, fn, &quot;(&quot;, distinct and &quot;DISTINCT&quot; or &quot;&quot;, field.name, &quot;)&quot;, &quot;AS&quot;, fn, &quot;FROM&quot;, s_name}

   if query then
      sql_chunks[#sql_chunks+1] = &quot;WHERE&quot;
      if type(query) == &quot;table&quot; then
         sql_chunks[#sql_chunks+1] = db:AND(unpack(query))
      else
         sql_chunks[#sql_chunks+1] = query
      end
   end

   local sql = table.concat(sql_chunks, &quot; &quot;)

   db:echo_sql(sql)
   local cur = conn:execute(sql)

   if cur ~= 0 then
      local row = cur:fetch({}, &quot;a&quot;)
      local count = row[fn]
      cur:close()
      
      -- give back the correct data type. see http://www.sqlite.org/lang_aggfunc.html
      if (fn:upper() ~= &quot;MIN&quot; and fn:upper() ~= &quot;MAX&quot;) or field.type == &quot;number&quot; then
         return tonumber(count)
      end
      if field.type == &quot;string&quot; then
        return count
      end
      -- Only datetime left
      -- the value, count, is currently in a UTC timestamp
      local localtime = datetime:parse(count, nil, true)
      -- convert it into a UTC timestamp as datetime:parse parses it in the local time context
      count = db:Timestamp(localtime + datetime:calculate_UTCdiff(localtime))
      return count
   else
      return 0
   end
end



--- Deletes rows from the specified sheet. The argument for query tries to be intelligent: &lt;br/&gt;
--- * if it is a simple number, it deletes a specific row by _row_id &lt;br/&gt;
--- * if it is a table that contains a _row_id (e.g., a table returned by db:get) it deletes just that record. &lt;br/&gt;
--- * Otherwise, it deletes every record which matches the query pattern which is specified as with db:get. &lt;br/&gt;
--- * If the query is simply true, then it will truncate the entire contents of the sheet. &lt;br/&gt;
---
--- @usage When passed an actual result table that was obtained from db:fetch, it will delete the record for that table.
---   &lt;pre&gt;
---   enemies = db:fetch(mydb.enemies)
---   db:delete(mydb.enemies, enemies[1])
---   &lt;/pre&gt;
--- @usage When passed a number, will delete the record for that _row_id. This example shows getting the row id from a table.
---   &lt;pre&gt;
---   enemies = db:fetch(mydb.enemies)
---   db:delete(mydb.enemies, enemies[1]._row_id)
---   &lt;/pre&gt;
--- @usage As above, but this example just passes in the row id directly.
---   &lt;pre&gt;
---   db:delete(mydb.enemies, 5)
---   &lt;/pre&gt;
--- @usage Here, we will delete anything which matches the same kind of query as db:fetch uses - namely,
---   anyone who is in the city of San Francisco.
---   &lt;pre&gt;
---   db:delete(mydb.enemies, db:eq(mydb.enemies.city, &quot;San Francisco&quot;))
---   &lt;/pre&gt;
--- @usage And finally, we will delete the entire contents of the enemies table.
---   &lt;pre&gt;
---   db:delete(mydb.enemies, true)
---   &lt;/pre&gt;
function db:delete(sheet, query)
   local db_name = sheet._db_name
   local s_name = sheet._sht_name

   local conn = db.__conn[db_name]

   assert(query, &quot;must pass a query argument to db:delete()&quot;)
   if type(query) == &quot;number&quot; then
      query = &quot;_row_id = &quot;..tostring(query)
   elseif type(query) == &quot;table&quot; then
      assert(query._row_id, &quot;Passed a non-result table to db:delete, need a _row_id field to continue.&quot;)
      query = &quot;_row_id = &quot;..tostring(query._row_id)
   end

   local sql = &quot;DELETE FROM &quot;..s_name

   if query ~= true then
      sql = sql..&quot; WHERE &quot;..query
   end

   db:echo_sql(sql)
   assert(conn:execute(sql))
   if db.__autocommit[db_name] then
      conn:commit()
   end
end



--- Merges the specified table array into the sheet, modifying any existing rows and adding any that don't exist.
---
--- This function is a convenience utility that allows you to quickly modify a sheet, changing
--- existing rows and add new ones as appropriate. It ONLY works on sheets which have a unique
--- index, and only when that unique index is only on a single field. For more complex situations
--- you'll have to do the logic yourself.
---
--- The table array may contain tables that were either returned previously by db:fetch, or new tables
--- that you've constructed with the correct fields, or any mix of both. Each table must have a value
--- for the unique key that has been set on this sheet.
---
--- @usage For example, consider this database:
---   &lt;pre&gt;
---   local mydb = db:create(&quot;peopledb&quot;,
---     {
---       friends = {
---         name = &quot;&quot;,
---         race = &quot;&quot;,
---         level = 0,
---         city = &quot;&quot;,
---         _index = { &quot;city&quot; },
---         _unique = { &quot;name&quot; }
---       }
---     }
---   )
---   &lt;/pre&gt;
---
---   Here you have a database with one sheet, which contains your friends, their race, level,
---   and what city they live in. Let's say you want to fetch everyone who lives in San Francisco, you could do:
---   &lt;pre&gt;
---   local results = db:fetch(mydb.friends, db:eq(mydb.friends.city, &quot;San Francisco&quot;))
---   &lt;/pre&gt;
---
---   The tables in results are static, any changes to them are not saved back to the database.
---   But after a major radioactive cataclysm rendered everyone in San Francisco a mutant,
---   you could make changes to the tables as so:
---   &lt;pre&gt;
---   for _, friend in ipairs(results) do
---     friend.race = &quot;Mutant&quot;
---   end
---   &lt;/pre&gt;
---
---   If you are also now aware of a new arrival in San Francisco, you could add them to that existing table array:
---   &lt;pre&gt;
---   results[#results+1] = {name=&quot;Bobette&quot;, race=&quot;Mutant&quot;, city=&quot;San Francisco&quot;}
---   &lt;/pre&gt;
---
---   And commit all of these changes back to the database at once with:
---   &lt;pre&gt;
---   db:merge_unique(mydb.friends, results)
---   &lt;/pre&gt;
---
---   The db:merge_unique function will change the 'city' values for all the people who we previously fetched, but then add a new record as well.
function db:merge_unique(sheet, tables)
   assert(type(tables) == &quot;table&quot;, &quot;db:merge_unique: missing the required table of data to merge&quot;)

   local db_name = sheet._db_name
   local s_name = sheet._sht_name

   local unique_options = db.__schema[db_name][s_name].options._unique
   assert(unique_options, &quot;db:merge_unique only works on a sheet with a unique index.&quot;)
   assert(#unique_options == 1, &quot;db:merge_unique only works on a sheet with a single unique index.&quot;)

   local unique_index = unique_options[1]
   local unique_key = &quot;&quot;
   if type(unique_index) == &quot;table&quot; then
      assert(#unique_index == 1, &quot;db:merge_unique currently only supports sheets with a single unique index with a single column.&quot;)
      unique_key = unique_index[1]
   else
      unique_key = unique_index
   end

   db:echo_sql(&quot;:: Unique index = &quot;..unique_key)

   local conn = db.__conn[db_name]
   local mydb = db:get_database(db_name)
   mydb:_begin()

   for _, tbl in ipairs(tables) do
      assert(tbl[unique_key], &quot;attempting to db:merge_unique with a table that does not have the unique key.&quot;)

      local results = db:fetch(sheet, db:eq(sheet[unique_key], tbl[unique_key]))
      if results and results[1] then
         local t = results[1]
         for k, v in pairs(tbl) do
            t[k] = v
         end

         db:update(sheet, t)
      else
         db:add(sheet, tbl)
      end
   end

   mydb:_commit()
   mydb:_end()
end



--- This function updates a row in the specified sheet, but only accepts a row which has been previously
--- obtained by db:fetch. Its primary purpose is that if you do a db:fetch, then change the value of a field
--- or tow, you can save back that table.
---
--- @usage This obtains a database reference, and queries the friends sheet for someone named Bob. As this
---   returns a table array containing only one item, it assigns that one item to the local variable named bob.
---   We then change the notes on Bob, and pass it into db:update() to save the changes back.
---   &lt;pre&gt;
---   local mydb = db:get_database(&quot;my database&quot;)
---   local bob = db:fetch(mydb.friends, db:eq(mydb.friends.name, &quot;Bob&quot;))[1]
---   bob.notes = &quot;He's a really awesome guy.&quot;
---   db:update(mydb.friends, bob)
---   &lt;/pre&gt;
function db:update(sheet, tbl)
   assert(tbl._row_id, &quot;Can only update a table with a _row_id&quot;)
   assert(not table.is_empty(tbl), &quot;An empty table was passed to db:update&quot;)

   local db_name = sheet._db_name
   local s_name = sheet._sht_name

   local conn = db.__conn[db_name]

   local sql_chunks = {&quot;UPDATE OR&quot;, db.__schema[db_name][s_name].options._violations, s_name, &quot;SET&quot;}

   local set_chunks = {}
   local set_block = [[&quot;%s&quot; = %s]]

   for k, v in pairs(db.__schema[db_name][s_name]['columns']) do
      if tbl[k] then
         local field = sheet[k]
         set_chunks[#set_chunks+1] = set_block:format(k, db:_coerce(field, tbl[k]))
      end
   end

   sql_chunks[#sql_chunks+1] = table.concat(set_chunks, &quot;,&quot;)
   sql_chunks[#sql_chunks+1] = &quot;WHERE _row_id = &quot;..tbl._row_id

   local sql = table.concat(sql_chunks, &quot; &quot;)
   db:echo_sql(sql)
   assert(conn:execute(sql))
   if db.__autocommit[db_name] then
      conn:commit()
   end
end



--- The db:set function allows you to set a certain field to a certain value across an entire sheet.
--- Meaning, you can change all of the last_read fields in the sheet to a certain value, or possibly only
--- the last_read fields which are in a certain city. The query argument can be any value which is appropriate
--- for db:fetch, even nil which will change the value for the specified column for EVERY row in the sheet.
---
--- For example, consider a situation in which you are tracking how many times you find a certain
--- type of egg during Easter. You start by setting up your database and adding an Eggs sheet, and
--- then adding a record for each type of egg.
---   &lt;pre&gt;
---   local mydb = db:create(&quot;egg database&quot;, {eggs = {color = &quot;&quot;, last_found = db.Timestamp(false), found = 0}})
---   db:add(mydb.eggs,
---     {color = &quot;Red&quot;},
---     {color = &quot;Blue&quot;},
---     {color = &quot;Green&quot;},
---     {color = &quot;Yellow&quot;},
---     {color = &quot;Black&quot;}
---   )
---   &lt;/pre&gt;
---
--- Now, you have three columns. One is a string, one a timestamp (that ends up as nil in the database),
--- and one is a number. &lt;br/&gt;&lt;br/&gt;
---
--- You can then set up a trigger to capture from the mud the string, &quot;You pick up a (.*) egg!&quot;, and you
--- end up arranging to store the value of that expression in a variable called &quot;myegg&quot;. &lt;br/&gt;&lt;br/&gt;
---
--- To increment how many we found, we will do this:
---   &lt;pre&gt;
---   myegg = &quot;Red&quot; -- We will pretend a trigger set this.
---   db:set(mydb.eggs.found, db:exp(&quot;found + 1&quot;), db:eq(mydb.eggs.color, myegg))
---   db:set(mydb.eggs.last_found, db.Timestamp(&quot;CURRENT_TIMESTAMP&quot;), db:eq(mydb.eggs.color, myegg))
---   &lt;/pre&gt;
---
--- This will go out and set two fields in the Red egg sheet; the first is the found field, which will
--- increment the value of that field (using the special db:exp function). The second will update the
--- last_found field with the current time. &lt;br/&gt;&lt;br/&gt;
---
--- Once this contest is over, you may wish to reset this data but keep the database around.
--- To do that, you may use a more broad use of db:set as such:
---   &lt;pre&gt;
---   db:set(mydb.eggs.found, 0)
---   db:set(mydb.eggs.last_found, nil)
---   &lt;/pre&gt;
function db:set(field, value, query)
   local db_name = field.database
   local s_name = field.sheet

   local conn = db.__conn[db_name]

   local sql_update = [[UPDATE OR %s %s SET &quot;%s&quot; = %s]]
   if query then
       sql_update = sql_update .. [[ WHERE %s]]
   end

   local sql = sql_update:format(db.__schema[db_name][s_name].options._violations, s_name, field.name, db:_coerce(field, value), query)

   db:echo_sql(sql)
   assert(conn:execute(sql))
   if db.__autocommit[db_name] then
      conn:commit()
   end
end



--- This is a debugging function, which echos any SQL commands if db.debug_sql is true.
--- You should not call this function directly from Mudlet.
---
--- @usage Set following lua variable to enable SQL echos.
---   &lt;pre&gt;
---   db.debug_sql=true
---   &lt;/pre&gt;
function db:echo_sql(sql)
   if db.debug_sql then
      print(sql)
   end
end



-- NOT LUADOC
-- After a table so retrieved from the database, this function coerces values to
-- their proper types. Specifically, numbers and datetimes become the proper
-- types.
function db:_coerce_sheet(sheet, tbl)
   if tbl then
      tbl._row_id = tonumber(tbl._row_id)

      for k, v in pairs(tbl) do
         if k ~= &quot;_row_id&quot; then
            local field = sheet[k]
            if field.type == &quot;number&quot; then
               tbl[k] = tonumber(tbl[k]) or tbl[k]
            elseif field.type == &quot;datetime&quot; then
               -- the value, tbl[k], is currently in a UTC timestamp
               local localtime = datetime:parse(tbl[k], nil, true)
               -- convert it into a UTC timestamp as datetime:parse parses it in the local time context
               tbl[k] = db:Timestamp(localtime + datetime:calculate_UTCdiff(localtime))
            end
         end
      end
      return tbl
   end
end



-- NOT LUADOC
-- The function converts a Lua value into its SQL representation, depending on the
-- type of the specified field. Strings will be single-quoted (and single-quotes
-- within will be properly escaped), numbers will be rendered properly, and such.
function db:_coerce(field, value)
   if field.type == &quot;number&quot; then
      return tonumber(value) or &quot;'&quot;..value..&quot;'&quot;
   elseif field.type == &quot;datetime&quot; then
      if value._timestamp == false then
         return &quot;NULL&quot;
      else
         return &quot;datetime('&quot;..value._timestamp..&quot;', 'unixepoch')&quot; or &quot;'&quot;..value..&quot;'&quot;
      end
   else
      return &quot;'&quot;..tostring(value):gsub(&quot;'&quot;, &quot;''&quot;)..&quot;'&quot;
   end
end



--- Returns a database expression to test if the field in the sheet is equal to the value.
---
--- @see db:fetch
function db:eq(field, value, case_insensitive)
   local fieldname = field.name
   -- escape column names as per https://www.sqlite.org/lang_expr.html
   fieldname = '&quot;'..fieldname:gsub(&quot;'&quot;, &quot;''&quot;)..'&quot;'
   if case_insensitive then
      local v = db:_coerce(field, value):lower()
      return &quot;lower(&quot;..fieldname..&quot;) == &quot;..v
   else
      local v = db:_coerce(field, value)
      return fieldname..&quot; == &quot;..v
   end
end



--- Returns a database expression to test if the field in the sheet is NOT equal to the value.
---
--- @see db:fetch
function db:not_eq(field, value, case_insensitive)
   if case_insensitive then
      local v = db:_coerce(field, value):lower()
      return &quot;lower(&quot;..field.name..&quot;) != &quot;..v
   else
      local v = db:_coerce(field, value)
      return field.name..&quot; != &quot;..v
   end
end



--- Returns a database expression to test if the field in the sheet is less than the value.
---
--- @see db:fetch
function db:lt(field, value)
   local v = db:_coerce(field, value)
   return field.name..&quot; &lt; &quot;..v
end



--- Returns a database expression to test if the field in the sheet is less than or equal to the value.
---
--- @see db:fetch
function db:lte(field, value)
   local v = db:_coerce(field, value)
   return field.name..&quot; &lt;= &quot;..v
end



--- Returns a database expression to test if the field in the sheet is greater than to the value.
---
--- @see db:fetch
function db:gt(field, value)
   local v = db:_coerce(field, value)
   return field.name..&quot; &gt; &quot;..v
end



--- Returns a database expression to test if the field in the sheet is greater than or equal to the value.
---
--- @see db:fetch
function db:gte(field, value)
   local v = db:_coerce(field, value)
   return field.name..&quot; &gt;= &quot;..v
end



--- Returns a database expression to test if the field in the sheet is nil.
---
--- @see db:fetch
function db:is_nil(field)
   return field.name..&quot; IS NULL&quot;
end



--- Returns a database expression to test if the field in the sheet is not nil.
---
--- @see db:fetch
function db:is_not_nil(field)
   return field.name..&quot; IS NOT NULL&quot;
end



--- Returns a database expression to test if the field in the sheet matches the specified pattern. &lt;br/&gt;&lt;br/&gt;
---
--- LIKE patterns are not case-sensitive, and allow two wild cards. The first is an underscore which matches
--- any single one character. The second is a percent symbol which matches zero or more of any character.
---   &lt;pre&gt;
---   LIKE with &quot;_&quot; is therefore the same as the &quot;.&quot; regular expression.
---   LIKE with &quot;%&quot; is therefore the same as &quot;.*&quot; regular expression.
---   &lt;/pre&gt;
---
--- @see db:not_like
--- @see db:fetch
function db:like(field, value)
   local v = db:_coerce(field, value)
   return field.name..&quot; LIKE &quot;..v
end



--- Returns a database expression to test if the field in the sheet does not match the specified pattern.
---
--- LIKE patterns are not case-sensitive, and allow two wild cards. The first is an underscore which matches
--- any single one character. The second is a percent symbol which matches zero or more of any character.
---   &lt;pre&gt;
---   LIKE with &quot;_&quot; is therefore the same as the &quot;.&quot; regular expression.
---   LIKE with &quot;%&quot; is therefore the same as &quot;.*&quot; regular expression.
---   &lt;/pre&gt;
---
--- @see db:like
--- @see db:fetch
function db:not_like(field, value)
   local v = db:_coerce(field, value)
   return field.name..&quot; NOT LIKE &quot;..v
end



--- Returns a database expression to test if the field in the sheet is a value between lower_bound and upper_bound.
--- This only really makes sense for numbers and Timestamps.
---
--- @see db:not_between
--- @see db:fetch
function db:between(field, left_bound, right_bound)
   local x = db:_coerce(field, left_bound)
   local y = db:_coerce(field, right_bound)
   return field.name..&quot; BETWEEN &quot;..x..&quot; AND &quot;..y
end



--- Returns a database expression to test if the field in the sheet is NOT a value between lower_bound and upper_bound.
--- This only really makes sense for numbers and Timestamps.
---
--- @see db:between
--- @see db:fetch
function db:not_between(field, left_bound, right_bound)
   local x = db:_coerce(field, left_bound)
   local y = db:_coerce(field, right_bound)
   return field.name..&quot; NOT BETWEEN &quot;..x..&quot; AND &quot;..y
end



--- Returns a database expression to test if the field in the sheet is one of the values in the table array. &lt;br/&gt;&lt;br/&gt;
---
--- First, note the trailing underscore carefully! It is required.
---
--- @usage The following example illustrates the use of &lt;b&gt;in_&lt;/b&gt;:
---   This will obtain all of your kills which happened in the Undervault, Hell or Purgatory. Every db:in_ expression
---   can be written as a db:OR, but that quite often gets very complex.
---   &lt;pre&gt;
---   local mydb = db:get_database(&quot;my database&quot;)
---   local areas = {&quot;Undervault&quot;, &quot;Hell&quot;, &quot;Purgatory&quot;}
---   db:fetch(mydb.kills, db:in_(mydb.kills.area, areas))
---   &lt;/pre&gt;
---
--- @see db:fetch
function db:in_(field, tbl)
   local parts = {}
   for _, v in ipairs(tbl) do
      parts[#parts+1] = db:_coerce(field, v)
   end

   return field.name..&quot; IN (&quot;..table.concat(parts, &quot;,&quot;)..&quot;)&quot;
end



--- Returns a database expression to test if the field in the sheet is not one of the values in the table array.
---
--- @see db:in_
--- @see db:fetch
function db:not_in(field, tbl)
   local parts = {}
   for _, v in ipairs(tbl) do
      parts[#parts+1] = db:_coerce(field, v)
   end

   return field.name..&quot; NOT IN (&quot;..table.concat(parts, &quot;,&quot;)..&quot;)&quot;
end



--- Returns the string as-is to the database. &lt;br/&gt;&lt;br/&gt;
---
--- Use this function with caution, but it is very useful in some circumstances. One of the most
--- common of such is incrementing an existing field in a db:set() operation, as so:
---   &lt;pre&gt;
---   db:set(mydb.enemies, db:exp(&quot;kills + 1&quot;), db:eq(mydb.enemies.name, &quot;Ixokai&quot;))
---   &lt;/pre&gt;
---
--- This will increment the value of the kills field for the row identified by the name Ixokai. &lt;br/&gt;&lt;br/&gt;
---
--- But there are other uses, as the underlining database layer provides many functions you can call
--- to do certain things. If you want to get a list of all your enemies who have a name longer then
--- 10 characters, you may do:
---   &lt;pre&gt;
---   db:fetch(mydb.enemies, db:exp(&quot;length(name) &gt; 10&quot;))
---   &lt;/pre&gt;
---
--- Again, take special care with this, as you are doing SQL syntax directly and the library can't
--- help you get things right.
---
--- @see db:fetch
function db:exp(text)
   return text
end



--- Returns a compound database expression that combines all of the simple expressions passed into it.
--- These expressions should be generated with other db: functions such as db:eq, db:like, db:lt and the like. &lt;br/&gt;&lt;br/&gt;
---
--- This compound expression will only find items in the sheet if all sub-expressions match.
---
--- @see db:fetch
function db:AND(...)
   local parts = {}

   for _, expression in ipairs({...}) do
      parts[#parts+1] = &quot;(&quot;..expression..&quot;)&quot;
   end

   return &quot;(&quot;..table.concat(parts, &quot; AND &quot;)..&quot;)&quot;
end



--- Returns a compound database expression that combines both of the simple expressions passed into it.
--- These expressions should be generated with other db: functions such as db:eq, db:like, db:lt and the like. &lt;br/&gt;&lt;br/&gt;
---
--- This compound expression will find any item that matches either the first or the second sub-expression.
---
--- @see db:fetch
function db:OR(left, right)
   if not string.starts(left, &quot;(&quot;) then
      left = &quot;(&quot;..left..&quot;)&quot;
   end

   if not string.starts(right, &quot;(&quot;) then
      right = &quot;(&quot;..right..&quot;)&quot;
   end

   return left..&quot; OR &quot;..right
end



--- &lt;b&gt;&lt;u&gt;TODO&lt;/u&gt;&lt;/b&gt;
function db:close()
   for _, c in pairs(db.__conn) do
      c:close()
   end
   db.__conn = {}
   db.__env:close()
   db.__env = nil
end



-- Timestamp support
db.__Timestamp = {}



db.__TimestampMT = {
   __index = db.__Timestamp
}


function db.__Timestamp:as_string(format)
   if not format then
      format = &quot;%m-%d-%Y %H:%M:%S&quot;
   end

   -- given how we have an as_string function, having to wrap it in tostring() is a bit silly. So in this case, return nil as a string
   if type(self._timestamp) ~= &quot;number&quot; then return &quot;nil&quot;, &quot;db.Timestamp:as_string: timestamp seems to be invalid and isn't a number&quot; end

   return os.date(format, self._timestamp)
end

function db.__Timestamp:as_table()
   if type(self._timestamp) ~= &quot;number&quot; then return nil, &quot;db.Timestamp:as_table: timestamp seems to be invalid and isn't a number&quot; end

   return os.date(&quot;*t&quot;, self._timestamp)
end

function db.__Timestamp:as_number()
   if type(self._timestamp) ~= &quot;number&quot; then return nil, &quot;db.Timestamp:as_number: timestamp seems to be invalid and isn't a number&quot; end

   return self._timestamp
end

function db.__Timestamp:set(timestamp)
   assert(type(timestamp) == &quot;number&quot;, &quot;db.Timestamp:set: timestamp needs to be a number&quot;)

   self._timestamp = timestamp
end


--- &lt;b&gt;&lt;u&gt;TODO&lt;/u&gt;&lt;/b&gt;
function db:Timestamp(ts, fmt)
   local dt = {}
   if type(ts) == &quot;table&quot; then
      dt._timestamp = os.time(ts)
   elseif type(ts) == &quot;number&quot; then
      dt._timestamp = ts
   elseif type(ts) == &quot;string&quot; and
           assert(ts == &quot;CURRENT_TIMESTAMP&quot;, &quot;The only strings supported by db.DateTime:new is CURRENT_TIMESTAMP&quot;) then
      dt._timestamp = &quot;CURRENT_TIMESTAMP&quot;
   elseif ts == nil then
      dt._timestamp = false
   else
      assert(nil, &quot;Invalid value passed to db.Timestamp()&quot;)
   end
   return setmetatable(dt, db.__TimestampMT)
end



db.Field = {}
db.__FieldMT = {
   __index = db.Field
}



db.Sheet = {}
db.__SheetMT = {
   __index = function(t, k)
      local v = rawget(db.Sheet, k)
      if v then
         return v
      end

      local db_name = rawget(t, &quot;_db_name&quot;)
      local sht_name = rawget(t, &quot;_sht_name&quot;)
      local f_name = k

      local errormsg = &quot;Attempt to access field %s in sheet %s in database %s that does not exist.&quot;

      local field = db.__schema[db_name][sht_name]['columns'][f_name]
      if assert(field, errormsg:format(k, sht_name, db_name)) then
         type_ = type(field)
         if type_ == &quot;table&quot; and field._timestamp then
            type_ = &quot;datetime&quot;
         end

         rt = setmetatable({database=db_name, sheet=sht_name, type=type_, name=f_name}, db.__FieldMT)
         rawset(t,k,rt)
         return rt
      end

   end
}



db.Database = {}
db.__DatabaseMT = {
   __index = function(t, k)
      local v = rawget(t, k)
      if v then
         return v
      end

      local v = rawget(db.Database, k)
      if v then
         return v
      end

      local db_name = rawget(t, &quot;_db_name&quot;)
      if assert(db.__schema[db_name][k], &quot;Attempt to access sheet '&quot;..k..&quot;'in db '&quot;..db_name..&quot;' that does not exist.&quot;) then
         rt = setmetatable({_db_name = db_name, _sht_name = k}, db.__SheetMT)
         rawset(t,k,rt)
         return rt
      end
   end
}



function db.Database:_begin()
   db.__autocommit[self._db_name] = false
end



function db.Database:_commit()
   local conn = db.__conn[self._db_name]
   conn:commit()
end



function db.Database:_rollback()
   local conn = db.__conn[self._db_name]
   conn:rollback()
end



function db.Database:_end()
   db.__autocommit[self._db_name] = true
end



function db.Database._drop(s_name)
   local conn = db.__conn[self._db_name]
   local schema = db.__schema[self._db_name]

   if schema.options._index then
      for _, value in schema.options._index do
         conn:execute(&quot;DROP INDEX IF EXISTS &quot; .. db:_index_name(s_name, value))
      end
   end

   if schema.options._unique then
      for _, value in schema.options._unique do
         conn:execute(&quot;DROP INDEX IF EXISTS &quot; .. db:_index_name(s_name, value))
      end
   end

   conn:execute(&quot;DROP TABLE IF EXISTS &quot;..s_name)
   conn:commit()
end



--- Returns a reference of an already existing database. This instance can be used to get references
--- to the sheets (and from there, fields) that are defined within the database. You use these
--- references to construct queries. &lt;br/&gt;&lt;br/&gt;
---
--- These references do not contain any actual data, they only point to parts of the database structure.
---
--- @usage If a database has a sheet named enemies, you can obtain a reference to that sheet by simply doing:
---   &lt;pre&gt;
---   local mydb = db:get_database(&quot;my database&quot;)
---   local enemies_ref = mydb.enemies
---   local name_ref = mydb.enemies.name
---   &lt;/pre&gt;
function db:get_database(db_name)
   db_name = db:safe_name(db_name)
   assert(db.__schema[db_name], &quot;Attempt to access database that does not exist.&quot;)

   db_inst = {_db_name = db_name}
   return setmetatable(db_inst, db.__DatabaseMT)
end

--- Queries for database content matching the given example. Different fields of
--- the example are AND connected.
--- &lt;/br&gt;
--- Field values should be strings and can contain the following values:
--- &lt;ul&gt;
---   &lt;li&gt;literal strings to search for
---   &lt;li&gt;comparison terms prepended with &amp;lt;, &amp;gt;, &amp;gt;=, &amp;lt;=, !=, &amp;lt;&amp;gt;
---       for number and date comparisons
---   &lt;li&gt;ranges with :: between lower and upper bound
---   &lt;li&gt;different single values combined by || as OR
---   &lt;li&gt;strings containing % for a single and _ for multiple wildcard
---       characters
--- &lt;/ul&gt;
--- &lt;br/&gt;
--- @param database Reference to the database that should be queried.
--- @param example  Query prototype that should be searched for.
--- @usage This example shows, how to use this function:
---   &lt;pre&gt;
---      mydb = db:create(&quot;mydb&quot;,
---        {
---          sheet = {
---            name = &quot;&quot;, id = 0, city = &quot;&quot;,
---            _index = { &quot;name&quot; },
---            _unique = { &quot;id&quot; },
---            _violations = &quot;FAIL&quot;
---          }
---        })
---      test_data = {
---        {name=&quot;Ixokai&quot;, city=&quot;Magnagora&quot;, id=1},
---        {name=&quot;Vadi&quot;, city=&quot;New Celest&quot;, id=2},
---        {name=&quot;Heiko&quot;, city=&quot;Hallifax&quot;, id=3},
---        {name=&quot;Keneanung&quot;, city=&quot;Hashan&quot;, id=4},
---        {name=&quot;Carmain&quot;, city=&quot;Mhaldor&quot;, id=5},
---        {name=&quot;Ixokai&quot;, city=&quot;Hallifax&quot;, id=6},
---      }
---      db:add(mydb.sheet, unpack(test_data))
---      res = db:query_by_example(mydb.sheet, { name = &quot;Ixokai&quot;})
---      display(res)
---      --[[
---      Prints
---      {
---        {
---          id = 1,
---          name = &quot;Ixokai&quot;,
---          city = &quot;Magnagora&quot;
---        },
---        {
---          id = 6,
---          name = &quot;Ixokai&quot;,
---          city = &quot;Hallifax&quot;
---        }
---      }
---      --]]
---   &lt;/pre&gt;
---
--- @usage This example shows, how to combine two fields:
---   &lt;pre&gt;
---      mydb = db:create(&quot;mydb&quot;,
---        {
---          sheet = {
---            name = &quot;&quot;, id = 0, city = &quot;&quot;,
---            _index = { &quot;name&quot; },
---            _unique = { &quot;id&quot; },
---            _violations = &quot;FAIL&quot;
---          }
---        })
---      test_data = {
---        {name=&quot;Ixokai&quot;, city=&quot;Magnagora&quot;, id=1},
---        {name=&quot;Vadi&quot;, city=&quot;New Celest&quot;, id=2},
---        {name=&quot;Heiko&quot;, city=&quot;Hallifax&quot;, id=3},
---        {name=&quot;Keneanung&quot;, city=&quot;Hashan&quot;, id=4},
---        {name=&quot;Carmain&quot;, city=&quot;Mhaldor&quot;, id=5},
---      }
---      db:add(mydb.sheet, unpack(test_data))
---      res = db:query_by_example(mydb.sheet, { name = &quot;Ixokai&quot;, id = &quot;1&quot;})
---      display(res)
---      --[[
---      Prints
---      {
---        id = 1,
---        name = &quot;Ixokai&quot;,
---        city = &quot;Magnagora&quot;
---      }
---      --]]
---   &lt;/pre&gt;
function db:query_by_example(database, example)

   if table.is_empty(example) then return nil end

   local topLevel = {}
   local find = string.find
   local match = string.match

   for key, value in pairs(example) do

      value = string.trim(value)

      local op, exp = match(value, &quot;^%s*([&lt;&gt;=!]*)%s*(.*)$&quot;)

      if op == &quot;&lt;&quot; then
         topLevel[#topLevel + 1] = db:lt(database[key], exp)
      elseif op == &quot;&gt;&quot; then
         topLevel[#topLevel + 1] = db:gt(database[key], exp)
      elseif op == &quot;&gt;=&quot; then
         topLevel[#topLevel + 1] = db:gte(database[key], exp)
      elseif op == &quot;&lt;=&quot; then
         topLevel[#topLevel + 1] = db:lte(database[key], exp)
      elseif op == &quot;!=&quot; or op == &quot;&lt;&gt;&quot; then
         if find(exp, &quot;__NULL__&quot;, 1, true) then
            topLevel[#topLevel + 1] = db:is_not_nil(database[key])
         else
            topLevel[#topLevel + 1] = db:not_eq(database[key], exp)
         end
      else
         if find(value, &quot;%s*||%s*&quot;) then
            topLevel[#topLevel + 1] = db:in_(database[key], string.split(value,
&quot;%s*||%s*&quot;))
         elseif find(value, &quot;__NULL__&quot;, 1, true) then
            topLevel[#topLevel + 1] = db:is_nil(database[key])
         elseif find(value, &quot;_&quot;, 1, true) or find(value, &quot;%&quot;, 1, true) then
            topLevel[#topLevel + 1] = db:like(database[key], value)
         elseif find(value, &quot;::&quot;, 1, true) then
            topLevel[#topLevel + 1] = db:between(database[key], match(value, &quot;^(.-)::(.+)$&quot;))
         else
            topLevel[#topLevel + 1] = db:eq(database[key], value)
         end
      end

   end

   return db:AND(unpack(topLevel))
end

function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end
---------------------------------------------
--Switch code
---------------------------------------------
function switch(c)
  local swtbl = {
    casevar = c,
    caseof = function (self, code)
      local f
      if (self.casevar) then
        f = code[self.casevar] or code.default
      else
        f = code.missing or code.default
      end
      if f then
        if type(f)==&quot;function&quot; then
          return f(self.casevar,self)
        else
          error(&quot;case &quot;..tostring(self.casevar)..&quot; not a function&quot;)
        end
      end
    end
  }
  return swtbl
end</script>
            <eventHandlerList/>
        </Script>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>Other</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>startGame</name>
                <packageName></packageName>
                <script>function startGame()
	gmod.enableModule(&quot;Flec&quot;, &quot;IRE.Rift&quot;)
	gmod.enableModule(&quot;Flec&quot;, &quot;Comm.Channel&quot;)
	sendGMCP(&quot;IRE.Rift.Request&quot;)
	send(&quot; &quot;)

	riftListCreate()

	tarot = false
	CHAT = false
	isSelfish = true

echo(&quot;Startup successful!&quot;)
end
</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Roulette</name>
                <packageName></packageName>
                <script>betType = {	&quot; red&quot;, &quot; even&quot;,
			  	&quot; black&quot;, &quot; odd&quot;,
				&quot; green&quot;, &quot; t1&quot;, &quot; t2&quot;, &quot; t3&quot;,
				&quot; q1&quot;, &quot; q2&quot;, &quot; q3&quot;, &quot; q4&quot;}

function playRoulette()
	roll = (math.floor(math.random()*100)) % 13
	
	if roll == 0 then
		local randNum = (math.floor(math.random() * 100) % 38)
			if randNum == 37 then return &quot; 00&quot;
			else return &quot; &quot; .. randNum
			end
	else return betType[roll]
	end
end</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Class Skill Scripts</name>
                <packageName></packageName>
                <script>function makeBomb()
	if bombType == &quot;dust bomb&quot; then
		send(&quot;outr dust&quot;)
	elseif bombtype == &quot;web bomb&quot; then
		send(&quot;outr rope&quot;)
	else
		send(&quot;outr iron&quot;)
	end
	send(&quot;construct &quot; .. bombType)
end


function inscribeCard()
	send(&quot;curing off&quot;)
	send(&quot;inscribe blank with &quot; .. insCard)
end</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>quitGame</name>
                <packageName></packageName>
                <script>function quitGame()
	echo(&quot;Bye! Have a nice time!\n&quot;)
	gmod.disableModule(&quot;Flec&quot;, &quot;Comm.Channel&quot;)
	gmod.disableModule(&quot;Flec&quot;, &quot;IRE.Rift&quot;)
	send(&quot;qq&quot;)
end</script>
                <eventHandlerList>
                    <string>endGame</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>notQuit</name>
                <packageName></packageName>
                <script>function notQuit()

gmod.enableModule(&quot;Flec&quot;, &quot;IRE.Rift&quot;)
gmod.enableModule(&quot;Flec&quot;, &quot;Comm.Channel&quot;)

end</script>
                <eventHandlerList>
                    <string>returnGame</string>
                </eventHandlerList>
            </Script>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>Rift Stuff</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>Rift List Functions</name>
                <packageName></packageName>
                <script>function riftListCreate()
	riftList = {}
	local tableSize = table.size(gmcp.IRE.Rift.List)
	for i = 1, tableSize, 1 do
		local tempstring = gmcp.IRE.Rift.List[i].name
		riftList[tempstring] = tonumber(gmcp.IRE.Rift.List[i].amount)
	end
end

function riftListPrint()
	for riftable,amount in pairs(riftList) do
		print(riftable,amount)
	end
end

function isInRift(rifted)
	for riftable,amount in pairs(riftList) do
		--echo(&quot;checking &quot; .. rifted .. &quot; against &quot; .. riftable .. &quot;\n&quot;)
		if riftable == rifted then return true end
	end
	return false
end

function riftListCheckLarge(riftable)

	if not riftList[riftable] then
		echo(riftable .. &quot; IS NILL!\n&quot;)
	else
		if riftList[riftable] &lt; 2500 then
			return true
		else
			return false
		end
	end

end

function riftListCheckSmall(riftable)

	if riftList[riftable] &lt; 750 then

	return true else return false

	end

end</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>riftChange</name>
                <packageName></packageName>
                <script>function riftChange()
	riftList[gmcp.IRE.Rift.Change.name] = tonumber(gmcp.IRE.Rift.Change.amount)
end</script>
                <eventHandlerList>
                    <string>gmcp.IRE.Rift.Change</string>
                </eventHandlerList>
            </Script>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>Tradeskills</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Inkmilling</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Reagents</name>
                    <packageName></packageName>
                    <script>redagent = { clay = &quot;red clay&quot;, redchitin = &quot;red chitin&quot; }
blueagent = { bladder = &quot;ink bladder&quot;, lumic = &quot;lumic moss&quot; }
yellowagent = { yellowchitin = &quot;yellow chitin&quot; }
goldagent = { flakes = &quot;gold flakes&quot; }
commonagent = { scales = &quot;fish scales&quot; }
uncommonagent = { horn = &quot;buffalo horn&quot; }
scarseagent = { tooth = &quot;shark tooth&quot; }
rareagent = { wyrmtongue = &quot;wyrm tongue&quot; }

redink = { redagent, commonagent }
blueink = { blueagent, uncommonagent }
yellowink = { yellowagent, scarseagent }
greenink = { blueagent, blueagent, yellowagent, uncommonagent, uncommonagent, scarseagent }
purpleink = { redagent, redagent, blueagent, blueagent, commonagent, commonagent, uncommonagent, uncommonagent }
goldink = { goldagent, commonagent, commonagent, uncommonagent, uncommonagent, scarseagent, scarseagent, rareagent }</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>inkmilling functions</name>
                    <packageName></packageName>
                    <script>
function millredink()
	for i = 1, 5, 1 do
		for i, reagent in ipairs(redink) do
			local milled = false
			for mill, comm in pairs(reagent) do
				if isInRift(comm) then
					send(&quot;outr &quot; .. mill)
					milled = true
				end

				if not milled then return end

			end
		end
	end
	send(&quot;mill for 5 redink&quot;, false)
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Harvesting</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Harvest Lists and Variables</name>
                    <packageName></packageName>
                    <script>harTable = {}

Forest = { &quot;ginseng&quot;, &quot;echinacea&quot;, &quot;myrrh&quot;, &quot;elm&quot;, &quot;ginger&quot;, &quot;lobelia&quot; }
Garden = { &quot;echinacea&quot;, &quot;ginseng&quot;, &quot;myrrh&quot;, &quot;elm&quot;, &quot;ginger&quot;, &quot;lobelia&quot; }
Jungle = { &quot;skullcap&quot;, &quot;kuzu&quot;, &quot;kola&quot; }
Swamp = { &quot;cohosh&quot;, &quot;bellwort&quot;, &quot;ash&quot; }
Hills = { &quot;bayberry&quot;, &quot;hawthorn&quot; }
Cave = { &quot;bloodroot&quot;, &quot;moss&quot; }
Grasslands = { &quot;goldenseal&quot;, &quot;slipper&quot; }
Desert = { &quot;pear&quot;, &quot;weed&quot; }
Mountain = { &quot;valerian&quot; }
Water = { &quot;kelp&quot; }
Valley = { &quot;sileris&quot; }
	
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Harvesting Functions</name>
                    <packageName></packageName>
                    <script>function Harvest(har)

	if #harTable ~= 0 then
			send(&quot;harvest &quot; .. har[1])
	else
		cecho(&quot;\n&lt;lime_green&gt;Done Harvesting area.\n&quot;)
		isHar = 0
		tempTimer(0.0, detectAreaGat() )
	end
end

function startHarvest(area)
	isHar = 1
	harTable = deepcopy(area)
	Harvest(harTable)
end

function detectAreaHar()
	area = gmcp.Room.Info.environment

--	echo(&quot;Checking &quot; .. area .. &quot;...\n&quot;)

	if area == &quot;Garden&quot; then
		startHarvest(Garden)
	elseif area == &quot;Forest&quot; then
		startHarvest(Forest)
	elseif area == &quot;Jungle&quot; then
		startHarvest(Jungle)
	elseif area == &quot;Swamp&quot; then
		startHarvest(Swamp)
	elseif area == &quot;Desert&quot; then
		startHarvest(Desert)
	elseif area == &quot;Grasslands&quot; then
		startHarvest(Grasslands)
	elseif area == &quot;Hills&quot; then
		startHarvest(Hills)
	elseif area == &quot;Natural underground&quot; then
		startHarvest(Cave)
	elseif area == &quot;Mountains&quot; then
		startHarvest(Mountain)
	elseif area == &quot;Valley&quot; then
		startHarvest(Valley)
	elseif area == &quot;Freshwater&quot; or area == &quot;River&quot; or area == &quot;Ocean&quot; then
		startHarvest(Water)
	end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>harvest_area</name>
                    <packageName></packageName>
                    <script>function harvest_area()
	if harvestStart == true then
		detectAreaHar()
	end
end</script>
                    <eventHandlerList>
                        <string>gmcp.Room.Info</string>
                    </eventHandlerList>
                </Script>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>Gathering</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>Gathering Lists and Variables</name>
                        <packageName></packageName>
                        <script>gatTable = {}

gForest = { &quot;nut&quot; }
gGarden = { &quot;fruit&quot;, &quot;vegetable&quot;}
gJungle = { &quot;cacao&quot;, &quot;fruit&quot;}
gCave = { &quot;lumic moss&quot;, &quot;dust&quot; }
gGrasslands = { &quot;sugarcane&quot;, &quot;grain&quot; }
gRiver = { &quot;red clay&quot; }
gSalt = { &quot;saltwater&quot; }
gValley = { &quot;olive&quot; }</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>gather_area</name>
                        <packageName></packageName>
                        <script>function gather_area()
	if gatherStart == true then
		detectAreaGat()
	end
end</script>
                        <eventHandlerList>
                            <string>gmcp.Room.Info</string>
                        </eventHandlerList>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>Gathering Functions</name>
                        <packageName></packageName>
                        <script>function Gather(gat)

	if #gatTable ~= 0 then
		if gat[1] == &quot;red clay&quot; then
			send(&quot;gather clay&quot;)
		else
			send(&quot;gather &quot; .. gat[1])
		end
	else
		tempTimer(0.0, [[cecho(&quot;&lt;lime_green&gt;Done Gathering area.\n&quot;) ]] )
	end
end

function startGather(area)

	gatTable = deepcopy(area)
	Gather(gatTable)

end

function detectAreaGat()
	area = gmcp.Room.Info.environment

	if area == &quot;Garden&quot; then
		startGather(gGarden)
	elseif area == &quot;Forest&quot; then
		startGather(gForest)
	elseif area == &quot;Jungle&quot; then
		startGather(gJungle)
	elseif area == &quot;Grasslands&quot; then
		startGather(gGrasslands)
	elseif area == &quot;Natural underground&quot; then
		startGather(gCave)
	elseif area == &quot;Valley&quot; then
		startGather(gValley)
	elseif area == &quot;River&quot; then
		startGather(gRiver)
	elseif area == &quot;Ocean&quot; then
		startGather(gSalt)
	--else
	--	echo(&quot;\nSorry! Can't Gather!\n&quot;)
	end
end 

function refineIngredient()
	if refineAmt ~= 0 then
		send(&quot;refine for &quot; .. refining, false)
	end
end</script>
                        <eventHandlerList/>
                    </Script>
                </ScriptGroup>
            </ScriptGroup>
            <Script isActive="yes" isFolder="no">
                <name>Conjuration</name>
                <packageName></packageName>
                <script>function conjureItem(item)

if item == &quot;worrystone&quot;
	then conjureWorryStone()
elseif item == &quot;fist&quot;
	then conjureFist()
elseif item == &quot;flame&quot;
	then conjureFlame()
elseif item == &quot;brooch&quot;
	then conjureBrooch()
elseif item == &quot;key&quot;
	then conjureKey()
elseif item == &quot;eye&quot;
	then conjureEye()
else 
	echo(&quot;You can't conjure that.\n&quot;)
end
end

function conjureWorryStone()
echo(&quot;Coming soon.\n&quot;)
end

function conjureFist()
echo(&quot;Coming soon.\n&quot;)
end

function conjureFlame()
send(&quot;outr silver&quot;)
send(&quot;put silver in ouroboros&quot;)
send(&quot;begin creation of flame sigil&quot;)
send(&quot;chant flet lhar abe minlo eec&quot;)
tempTimer(4.0, [[send(&quot;chant flet lhar abe minlo eec&quot;)]])
tempTimer(8.0, [[send(&quot;chant flet lhar abe minlo eec&quot;)]])
tempTimer(12.0, [[send(&quot;ring bell&quot;)]])
tempTimer(16.0, [[send(&quot;end ritual&quot;)]])
tempTimer(16.1, [[send(&quot;get flame from ouroboros477034&quot;)]])
end

function conjureBrooch()
echo(&quot;Coming soon.\n&quot;)
end

function conjureKey()
send(&quot;outr gold&quot;)
send(&quot;put gold in ouroboros&quot;)
send(&quot;begin creation of key sigil&quot;)
send(&quot;chant krolop escit yall&quot;)
tempTimer(4.0, [[send(&quot;chant krolop escit yall&quot;)]])
tempTimer(8.0, [[send(&quot;chant krolop escit yall&quot;)]])
tempTimer(12.0, [[send(&quot;ring bell&quot;)]])
tempTimer(16.0, [[send(&quot;end ritual&quot;)]])
tempTimer(16.1, [[send(&quot;get key from ouroboros477034&quot;)]])
end

function conjureEye()
send(&quot;outr obsidian&quot;)
send(&quot;put obsidian in ouroboros&quot;)
send(&quot;begin creation of eye sigil&quot;)
send(&quot;square the circle&quot;)
tempTimer(4.0, [[send(&quot;ring bell&quot;)]])
tempTimer(8.0, [[send(&quot;end ritual&quot;)]])
tempTimer(8.1, [[send(&quot;get eye from ouroboros477034&quot;)]])
end</script>
                <eventHandlerList/>
            </Script>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>Windows</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Communication</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Main Chat Windows</name>
                    <packageName></packageName>
                    <script>menu = menu or {
  tabs = {&quot;City&quot;,&quot;House&quot;,&quot;Clans&quot;},
  color1 = &quot;rgb(0,0,70)&quot;,
  color2 = &quot;rgb(0,0,50)&quot;,
  width = &quot;40%&quot;,
  height = &quot;40%&quot;,
  current = &quot;City&quot;,
}

menu.container = Geyser.Container:new({
  name = &quot;menu.back&quot;,
  x = &quot;-42%&quot;, y = &quot;0%&quot;,
  width = menu.width,
  height = menu.height,
},main)

menu.header = Geyser.HBox:new({
  name = &quot;menu.header&quot;,
  x = 0, y = 0,
  width = &quot;100%&quot;,
  height = &quot;10%&quot;,
},menu.container)

menu.footer = Geyser.Label:new({
  name = &quot;menu.footer&quot;,
  x = 0, y = &quot;10%&quot;,
  width = &quot;100%&quot;,
  height = &quot;90%&quot;,
},menu.container)

menu.footer:setStyleSheet([[
  background-color: ]]..menu.color1..[[;
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 10px;
]])

menu.center = Geyser.Label:new({
  name = &quot;menu.center&quot;,
  x = 0, y = 0,
  width = &quot;100%&quot;,
  height = &quot;100%&quot;,
},menu.footer)
menu.center:setStyleSheet([[
  background-color: ]]..menu.color2..[[;
  border-radius: 10px;
  margin: 5px;
]])

for k,v in pairs(menu.tabs) do
  menu[v..&quot;tab&quot;] = Geyser.Label:new({
    name = &quot;menu.&quot;..v..&quot;tab&quot;,
  },menu.header)

  menu[v..&quot;tab&quot;]:setStyleSheet([[
    background-color: ]]..menu.color1..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
  ]])

  menu[v..&quot;tab&quot;]:echo(&quot;&lt;center&gt;&quot;..v)

  menu[v..&quot;tab&quot;]:setClickCallback(&quot;menu.click&quot;,v)

  menu[v] = Geyser.Label:new({
    name = &quot;menu.&quot;..v,
    x = 0, y = 0,
    width = &quot;100%&quot;,
    height = &quot;100%&quot;,
  },menu.footer)
 
  menu[v]:setStyleSheet([[
    background-color: ]]..menu.color1..[[;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
  ]])

  menu[v..&quot;center&quot;] = Geyser.MiniConsole:new({
    name = &quot;menu.&quot;..v..&quot;center&quot;,
    x = 0, y = 0,
    width = &quot;100%&quot;,
    height = &quot;100%&quot;,
  },menu[v])
  menu[v..&quot;center&quot;]:setColor(0,0,40)
  menu[v..&quot;center&quot;]:setWrap(78)

  menu[v]:hide()
end

function menu.click(tab)
  menu[menu.current]:hide()
  menu.current = tab
  menu[menu.current]:show()
  menu[menu.current .. &quot;tab&quot;]:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;%s&lt;/center&gt;&lt;/span&gt;&quot;, 255, 255, 255, tab))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Tells and Party Tabs</name>
                    <packageName></packageName>
                    <script>tmenu = tmenu or {
  tabs = {&quot;Tells&quot;, &quot;Party&quot;},
  color1 = &quot;rgb(0,0,70)&quot;,
  color2 = &quot;rgb(0,0,50)&quot;,
  width = &quot;40%&quot;,
  height = &quot;20%&quot;,
  current = &quot;Tells&quot;,
}

tmenu.container = Geyser.Container:new({
  name = &quot;tmenu.back&quot;,
  x = &quot;-42%&quot;, y = &quot;40%&quot;,
  width = tmenu.width,
  height = tmenu.height,
},main)

tmenu.header = Geyser.HBox:new({
  name = &quot;tmenu.header&quot;,
  x = 0, y = 0,
  width = &quot;100%&quot;,
  height = &quot;10%&quot;,
},tmenu.container)

tmenu.footer = Geyser.Label:new({
  name = &quot;tmenu.footer&quot;,
  x = 0, y = &quot;10%&quot;,
  width = &quot;100%&quot;,
  height = &quot;90%&quot;,
},tmenu.container)

tmenu.footer:setStyleSheet([[
  background-color: ]]..tmenu.color1..[[;
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 10px;
]])

tmenu.center = Geyser.Label:new({
  name = &quot;tmenu.center&quot;,
  x = 0, y = 0,
  width = &quot;100%&quot;,
  height = &quot;100%&quot;,
},tmenu.footer)
tmenu.center:setStyleSheet([[
  background-color: ]]..tmenu.color2..[[;
  border-radius: 10px;
  margin: 5px;
]])

for k,v in pairs(tmenu.tabs) do
  tmenu[v..&quot;tab&quot;] = Geyser.Label:new({
    name = &quot;tmenu.&quot;..v..&quot;tab&quot;,
  },tmenu.header)

  tmenu[v..&quot;tab&quot;]:setStyleSheet([[
    background-color: ]]..tmenu.color1..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
  ]])

  tmenu[v..&quot;tab&quot;]:echo(&quot;&lt;center&gt;&quot;..v)

  tmenu[v..&quot;tab&quot;]:setClickCallback(&quot;tmenu.click&quot;,v)

  tmenu[v] = Geyser.Label:new({
    name = &quot;tmenu.&quot;..v,
    x = 0, y = 0,
    width = &quot;100%&quot;,
    height = &quot;100%&quot;,
  },tmenu.footer)
 
  tmenu[v]:setStyleSheet([[
    background-color: ]]..tmenu.color1..[[;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
  ]])

  tmenu[v..&quot;center&quot;] = Geyser.MiniConsole:new({
    name = &quot;tmenu.&quot;..v..&quot;center&quot;,
    x = 0, y = 0,
    width = &quot;100%&quot;,
    height = &quot;100%&quot;,
  },tmenu[v])
  tmenu[v..&quot;center&quot;]:setColor(0,0,40)
  tmenu[v..&quot;center&quot;]:setWrap(78)

  tmenu[v]:hide()
end

function tmenu.click(tab)
  tmenu[tmenu.current]:hide()
  tmenu.current = tab
  tmenu[tmenu.current]:show()
  tmenu[tmenu.current .. &quot;tab&quot;]:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;%s&lt;/center&gt;&lt;/span&gt;&quot;, 255, 255, 255, tab))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>chatHandler</name>
                    <packageName></packageName>
                    <script>


function chatHandler()

	local chan = gmcp.Comm.Channel.Text.channel
	if not string.find(chan, &quot;clt&quot;) and not string.find(chan, &quot;hnt&quot;) and not string.find(chan, &quot;ht&quot;) and not string.find(chan, &quot;hnt&quot;)
	and not string.find(chan, &quot;hts&quot;) and not string.find(chan, &quot;ct&quot;) and not string.find(chan, &quot;tell&quot;)and not string.find(chan, &quot;party&quot;) then
		return
	end

	local messageText = string.sub(gmcp.Comm.Channel.Text.text, 8)
	messageText = string.sub(messageText, 1, -8)

	if chan == &quot;hnt&quot; then

		menu.Housecenter:cecho(&quot;&lt;dark_green&gt;&quot; .. messageText .. &quot;\n&quot;)
		if menu.current ~= &quot;House&quot; then
			menu.Housetab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;House&lt;/center&gt;&lt;/span&gt;&quot;, 0, 255, 0))
			tempTimer(0.5, [[menu.Housetab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;House&lt;/center&gt;&lt;/span&gt;&quot;, 255, 0, 0))]])
		end

	elseif chan == &quot;ht&quot; or chan == &quot;hts&quot; then

		menu.Housecenter:cecho(&quot;&lt;firebrick&gt;&quot; .. messageText .. &quot;\n&quot;)
		if menu.current ~= &quot;House&quot; then
			menu.Housetab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;House&lt;/center&gt;&lt;/span&gt;&quot;, 0, 255, 0))
			tempTimer(0.5, [[menu.Housetab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;House&lt;/center&gt;&lt;/span&gt;&quot;, 255, 0, 0))]])
		end

	elseif chan == &quot;ct&quot; then

		menu.Citycenter:cecho(&quot;&lt;dark_orange&gt;&quot; .. messageText .. &quot;\n&quot;)
		if menu.current ~= &quot;City&quot; then
			menu.Citytab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;City&lt;/center&gt;&lt;/span&gt;&quot;, 0, 255, 0))
			tempTimer(0.5, [[menu.Citytab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;City&lt;/center&gt;&lt;/span&gt;&quot;, 255, 0, 0))]])
		end

	elseif chan == &quot;party&quot; then
		tmenu.Partycenter:cecho(&quot;&lt;LavenderBlush&gt;&quot; .. messageText .. &quot;\n&quot;)
			if tmenu.current ~= &quot;Party&quot; then
				tmenu.Partytab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;Party&lt;/center&gt;&lt;/span&gt;&quot;, 0, 255, 0))
				tempTimer(0.5, [[tmenu.Partytab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;Party&lt;/center&gt;&lt;/span&gt;&quot;, 255, 0, 0))]])
			end

	elseif string.find(chan, &quot;tell&quot;) then

		if gmcp.Comm.Channel.Text.talker == &quot;You&quot; then
			tmenu.Tellscenter:cecho(&quot;&lt;DodgerBlue&gt;&quot; .. messageText .. &quot;\n&quot;)
		else
			tmenu.Tellscenter:cecho(&quot;&lt;yellow&gt;&quot; .. messageText .. &quot;\n&quot;)
			if tmenu.current ~= &quot;Tells&quot; then
				tmenu.Tellstab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;Tells&lt;/center&gt;&lt;/span&gt;&quot;, 0, 255, 0))
				tempTimer(0.5, [[tmenu.Tellstab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;Tells&lt;/center&gt;&lt;/span&gt;&quot;, 255, 0, 0))]])
			end
		end

	elseif string.find(chan, &quot;clt%d%d?&quot;) then

		menu.Clanscenter:cecho(messageText .. &quot;\n&quot;)
		if menu.current ~= &quot;Clans&quot; then
			menu.Clanstab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;Clans&lt;/center&gt;&lt;/span&gt;&quot;, 0, 255, 0))
			tempTimer(0.5, [[menu.Clanstab:echo(string.format(&quot;&lt;span style='color: rgb(%d,%d,%d)'&gt;&lt;center&gt;Clans&lt;/center&gt;&lt;/span&gt;&quot;, 255, 0, 0))]])
		end


	end

end</script>
                    <eventHandlerList>
                        <string>gmcp.Comm.Channel.Text</string>
                    </eventHandlerList>
                </Script>
            </ScriptGroup>
        </ScriptGroup>
    </ScriptPackage>
    <KeyPackage>
        <KeyGroup isActive="yes" isFolder="yes">
            <name>Walking</name>
            <packageName></packageName>
            <script></script>
            <command></command>
            <keyCode>-1</keyCode>
            <keyModifier>-1</keyModifier>
            <Key isActive="yes" isFolder="no">
                <name>Map</name>
                <packageName></packageName>
                <script>send(&quot;map&quot;)</script>
                <command></command>
                <keyCode>53</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>North</name>
                <packageName></packageName>
                <script></script>
                <command>North</command>
                <keyCode>56</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Northeast</name>
                <packageName></packageName>
                <script></script>
                <command>Northeast</command>
                <keyCode>57</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>East</name>
                <packageName></packageName>
                <script></script>
                <command>East</command>
                <keyCode>54</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Southeast</name>
                <packageName></packageName>
                <script></script>
                <command>Southeast</command>
                <keyCode>51</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>South</name>
                <packageName></packageName>
                <script></script>
                <command>South</command>
                <keyCode>50</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Southwest</name>
                <packageName></packageName>
                <script></script>
                <command>Southwest</command>
                <keyCode>49</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>West</name>
                <packageName></packageName>
                <script></script>
                <command>West</command>
                <keyCode>52</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Northwest</name>
                <packageName></packageName>
                <script></script>
                <command>Northwest</command>
                <keyCode>55</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Up</name>
                <packageName></packageName>
                <script></script>
                <command>Up</command>
                <keyCode>45</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Down</name>
                <packageName></packageName>
                <script></script>
                <command>Down</command>
                <keyCode>43</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>In</name>
                <packageName></packageName>
                <script></script>
                <command>In</command>
                <keyCode>42</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Out</name>
                <packageName></packageName>
                <script></script>
                <command>Out</command>
                <keyCode>47</keyCode>
                <keyModifier>536870912</keyModifier>
            </Key>
        </KeyGroup>
        <Key isActive="yes" isFolder="no">
            <name>Sounds key</name>
            <packageName></packageName>
            <script>playSoundFile(&quot;C:\Users\Wyatt\Music\Soundclips\HeyListen.wav&quot;)</script>
            <command></command>
            <keyCode>65</keyCode>
            <keyModifier>201326592</keyModifier>
        </Key>
        <KeyGroup isActive="yes" isFolder="yes">
            <name>Other</name>
            <packageName></packageName>
            <script></script>
            <command></command>
            <keyCode>-1</keyCode>
            <keyModifier>-1</keyModifier>
            <Key isActive="yes" isFolder="no">
                <name>HarvestStart</name>
                <packageName></packageName>
                <script>if not harvestStart then
	harvestStart = true
	echo(&quot;\nHARVESTING!\n\n&quot;)
else
	harvestStart = false
	echo(&quot;\nNOT HARVESTING!\n\n&quot;)
end</script>
                <command></command>
                <keyCode>72</keyCode>
                <keyModifier>100663296</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Selfishness</name>
                <packageName></packageName>
                <script>if isSelfish then
	send(&quot;generosity&quot;)
	isSelfish = false
else
	send(&quot;selfishness&quot;)
	isSelfish = true
end	</script>
                <command></command>
                <keyCode>83</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>GatherStart</name>
                <packageName></packageName>
                <script>if not gatherStart then
	gatherStart = true
	echo(&quot;\nGATHERING!\n\n&quot;)
else
	gatherStart = false
	echo(&quot;\nNOT GATHERING!\n\n&quot;)
end</script>
                <command></command>
                <keyCode>71</keyCode>
                <keyModifier>100663296</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Force Startup</name>
                <packageName></packageName>
                <script>gmod.enableModule(&quot;Flec&quot;, &quot;IRE.Rift&quot;)
gmod.enableModule(&quot;Flec&quot;, &quot;Comm.Channel&quot;)
sendGMCP(&quot;IRE.Rift.Request&quot;)
send(&quot; &quot;)

riftListCreate()

sip_bal = true
tarot = false
CHAT = false
isSelfish = true

echo(&quot;Startup successful!&quot;)</script>
                <command></command>
                <keyCode>83</keyCode>
                <keyModifier>234881024</keyModifier>
            </Key>
        </KeyGroup>
        <KeyGroup isActive="yes" isFolder="yes">
            <name>Combat</name>
            <packageName></packageName>
            <script></script>
            <command></command>
            <keyCode>-1</keyCode>
            <keyModifier>-1</keyModifier>
            <Key isActive="yes" isFolder="no">
                <name>Bop</name>
                <packageName></packageName>
                <script>send(&quot;Bop &quot; .. target)</script>
                <command></command>
                <keyCode>96</keyCode>
                <keyModifier>0</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Combat up</name>
                <packageName></packageName>
                <script>if combaton then
	send(&quot;relax grip&quot;)
	send(&quot;put blackjack in beltloop&quot;)
	send(&quot;lash shield&quot;)
	send(&quot;unwear scalemail&quot;)
	send(&quot;put scalemail in pack&quot;)
	combaton = false
else
	send(&quot;grip&quot;)
	send(&quot;get blackjack from beltloop&quot;)
	send(&quot;wield blackjack&quot;)
	send(&quot;wield shield&quot;)
	send(&quot;get scalemail from pack&quot;)
	send(&quot;wear scalemail&quot;)
	combaton = true
end</script>
                <command></command>
                <keyCode>96</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Noogie</name>
                <packageName></packageName>
                <script>send(&quot;noogie &quot; .. target)</script>
                <command></command>
                <keyCode>49</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Ensconce</name>
                <packageName></packageName>
                <script>send(&quot;ENSCONCE FIRECRACKER ON &quot; .. target)</script>
                <command></command>
                <keyCode>50</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Befuddle</name>
                <packageName></packageName>
                <script>send(&quot;befuddle &quot; .. target)</script>
                <command></command>
                <keyCode>51</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Jacks</name>
                <packageName></packageName>
                <script>send(&quot;throw jacks at &quot; .. target)</script>
                <command></command>
                <keyCode>81</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Dust Throw</name>
                <packageName></packageName>
                <script>send(&quot;dustthrow &quot; .. target)</script>
                <command></command>
                <keyCode>87</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Rap</name>
                <packageName></packageName>
                <script>send(&quot;rap &quot; .. target)</script>
                <command></command>
                <keyCode>69</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
            <Key isActive="yes" isFolder="no">
                <name>Shield</name>
                <packageName></packageName>
                <script>send(&quot;clearqueue all&quot;)
send(&quot;touch shield&quot;)</script>
                <command></command>
                <keyCode>84</keyCode>
                <keyModifier>67108864</keyModifier>
            </Key>
        </KeyGroup>
    </KeyPackage>
</MudletPackage>
